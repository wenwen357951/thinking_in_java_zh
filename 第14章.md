# 第14章 多線程


利用物件，可將一個程序分割成相互獨立的區域。我們通常也需要將一個程序轉換成多個獨立運行的子任務。

象這樣的每個子任務都叫作一個“線程”（`Thread`）。編寫程序時，可將每個線程都想象成獨立運行，而且都有自己的專用CPU。一些基礎機制實際會為我們自動分割CPU的時間。我們通常不必關心這些細節問題，所以多線程的程式碼編寫是相當簡便的。

這時理解一些定義對以後的學習狠有幫助。“進程”是指一種“自包容”的運行程序，有自己的地址空間。“多任務”操作系統能同時運行多個進程（程序）——但實際是由於CPU分時機制的作用，使每個進程都能循環獲得自己的CPU時間片。但由於輪換速度非常快，使得所有程序好象是在“同時”運行一樣。“線程”是進程內部單一的一個順序控制流。因此，一個進程可能容納了多個同時執行的線程。

多線程的應用範圍很廣。但在一般情況下，程序的一些部分同特定的事件或資源聯繫在一起，同時又不想為它而暫停程序其他部分的執行。這樣一來，就可考慮創建一個線程，令其與那個事件或資源關聯到一起，並讓它獨立於主程序運行。一個很好的例子便是“Quit”或“退出”按鈕——我們並不希望在程序的每一部分程式碼中都輪詢這個按鈕，同時又希望該按鈕能及時地作出響應（使程序看起來似乎經常都在輪詢它）。事實上，多線程最主要的一個用途就是構建一個“反應靈敏”的用戶界面。


# 14.1 反應靈敏的用戶界面

作為我們的起點，請思考一個需要執行某些CPU密集型計算的程序。由於CPU“全心全意”為那些計算服務，所以對用戶的輸入十分遲鈍，幾乎沒有什麼反應。在這裡，我們用一個組合的applet/application（程序片／應用程序）來簡單顯示出一個計數器的結果：

```
//: Counter1.java
// A non-responsive user interface
package c14;
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

public class Counter1 extends Applet {
  private int count = 0;
  private Button
    onOff = new Button("Toggle"),
    start = new Button("Start");
  private TextField t = new TextField(10);
  private boolean runFlag = true;
  public void init() {
    add(t);
    start.addActionListener(new StartL());
    add(start);
    onOff.addActionListener(new OnOffL());
    add(onOff);
  }
  public void go() {
    while (true) {
      try {
        Thread.currentThread().sleep(100);
      } catch (InterruptedException e){}
      if(runFlag)
        t.setText(Integer.toString(count++));
    }
  }
  class StartL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      go();
    }
  }
  class OnOffL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      runFlag = !runFlag;
    }
  }
  public static void main(String[] args) {
    Counter1 applet = new Counter1();
    Frame aFrame = new Frame("Counter1");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(300,200);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

在這個程序中，AWT和程序片程式碼都應是大家熟悉的，第13章對此已有很詳細的交待。`go()`方法正是程序全心全意服務的對待：將當前的`count`（計數）值置入`TextField`（文本字段）`t`，然後使`count`自增。

`go()`內的部分無限循環是呼叫`sleep()`。`sleep()`必須同一個`Thread`（線程）物件關聯到一起，而且似乎每個應用程序都有部分線程同它關聯（事實上，Java本身就是建立在線程基礎上的，肯定有一些線程會伴隨我們寫的應用一起運行）。所以無論我們是否明確使用了線程，都可利用`Thread.currentThread()`產生由程序使用的當前線程，然後為那個線程呼叫`sleep()`。注意，`Thread.currentThread()`是`Thread`類的一個靜態方法。

注意`sleep()`可能“拋”出一個`InterruptException`（中斷異常）——儘管產生這樣的異常被認為是中止線程的一種“惡意”手段，而且應該儘可能地杜絕這一做法。再次提醒大家，異常是為異常情況而產生的，而不是為了正常的控制流。在這裡包含了對一個“睡眠”線程的中斷，以支持未來的一種語言特性。

一旦按下`start`按鈕，就會呼叫`go()`。研究一下`go()`，你可能會很自然地（就象我一樣）認為它該支持多線程，因為它會進入“睡眠”狀態。也就是說，儘管方法本身“睡著”了，CPU仍然應該忙於監視其他按鈕“按下”事件。但有一個問題，那就是`go()`是永遠不會返回的，因為它被設計成一個無限循環。這意味著`actionPerformed()`根本不會返回。由於在第一個按鍵以後便陷入`actionPerformed()`中，所以程序不能再對其他任何事件進行控制（如果想出來，必須以某種方式“殺死”進程——最簡便的方式就是在控制檯窗口按`Ctrl+C`鍵）。

這裡最基本的問題是`go()`需要繼續執行自己的操作，而與此同時，它也需要返回，以便`actionPerformed()`能夠完成，而且用戶界面也能繼續響應用戶的操作。但物件`go()`這樣的傳統方法來說，它卻不能在繼續的同時將控制權返回給程序的其他部分。這聽起來似乎是一件不可能做到的事情，就象CPU必須同時位於兩個地方一樣，但線程可以解決一切。“線程模型”（以及Java中的編程支持）是一種程序編寫規範，可在單獨一個程序裡實作幾個操作的同時進行。根據這一機制，CPU可為每個線程都分配自己的一部分時間。每個線程都“感覺”自己好象擁有整個CPU，但CPU的計算時間實際卻是在所有線程間分攤的。

線程機制多少降低了一些計算效率，但無論程序的設計，資源的均衡，還是用戶操作的方便性，都從中獲得了巨大的利益。綜合考慮，這一機制是非常有價值的。當然，如果本來就安裝了多塊CPU，那麼操作系統能夠自行決定為不同的CPU分配哪些線程，程序的總體運行速度也會變得更快（所有這些都要求操作系統以及應用程序的支持）。多線程和多任務是充分發揮多處理機系統能力的一種最有效的方式。

## 14.1.1 從線程繼承

為創建一個線程，最簡單的方法就是從`Thread`類繼承。這個類包含了創建和運行線程所需的一切東西。`Thread`最重要的方法是`run()`。但為了使用`run()`，必須對其進行重載或者覆蓋，使其能充分按自己的吩咐行事。因此，`run()`屬於那些會與程序中的其他線程“併發”或“同時”執行的程式碼。

下面這個例子可創建任意數量的線程，並通過為每個線程分配一個獨一無二的編號（由一個靜態變量產生），從而對不同的線程進行跟蹤。`Thread`的`run()`方法在這裡得到了覆蓋，每通過一次循環，計數就減1——計數為0時則完成循環（此時一旦返回run()，線程就中止運行）。

```
//: SimpleThread.java
// Very simple Threading example

public class SimpleThread extends Thread {
  private int countDown = 5;
  private int threadNumber;
  private static int threadCount = 0;
  public SimpleThread() {
    threadNumber = ++threadCount;
    System.out.println("Making " + threadNumber);
  }
  public void run() {
    while(true) {
      System.out.println("Thread " +
        threadNumber + "(" + countDown + ")");
      if(--countDown == 0) return;
    }
  }
  public static void main(String[] args) {
    for(int i = 0; i < 5; i++)
      new SimpleThread().start();
    System.out.println("All Threads Started");
  }
} ///:~
```

`run()`方法幾乎肯定含有某種形式的循環——它們會一直持續到線程不再需要為止。因此，我們必須規定特定的條件，以便中斷並退出這個循環（或者在上述的例子中，簡單地從`run()`返回即可）。`run()`通常採用一種無限循環的形式。也就是說，通過阻止外部發出對線程的`stop()`或者`destroy()`呼叫，它會永遠運行下去（直到程序完成）。

在`main()`中，可看到創建並運行了大量線程。`Thread`包含了一個特殊的方法，叫作`start()`，它的作用是對線程進行特殊的初始化，然後呼叫`run()`。所以整個步驟包括：呼叫構造器來構建物件，然後用`start()`配置線程，再呼叫`run()`。如果不呼叫`start()`——如果適當的話，可在構造器那樣做——線程便永遠不會啟動。

下面是該程序某一次運行的輸出（注意每次運行都會不同）：

```
Making 1
Making 2
Making 3
Making 4
Making 5
Thread 1(5)
Thread 1(4)
Thread 1(3)
Thread 1(2)
Thread 2(5)
Thread 2(4)
Thread 2(3)
Thread 2(2)
Thread 2(1)
Thread 1(1)
All Threads Started
Thread 3(5)
Thread 4(5)
Thread 4(4)
Thread 4(3)
Thread 4(2)
Thread 4(1)
Thread 5(5)
Thread 5(4)
Thread 5(3)
Thread 5(2)
Thread 5(1)
Thread 3(4)
Thread 3(3)
Thread 3(2)
Thread 3(1)
```

可注意到這個例子中到處都呼叫了`sleep()`，然而輸出結果指出每個線程都獲得了屬於自己的那一部分CPU執行時間。從中可以看出，儘管`sleep()`依賴一個線程的存在來執行，但卻與允許或禁止線程無關。它只不過是另一個不同的方法而已。

亦可看出線程並不是按它們創建時的順序運行的。事實上，CPU處理一個現有線程集的順序是不確定的——除非我們親自介入，並用`Thread`的`setPriority()`方法調整它們的優先級。

`main()`創建`Thread`物件時，它並未捕獲任何一個物件的引用。普通物件對於垃圾收集來說是一種“公平競賽”，但線程卻並非如此。每個線程都會“註冊”自己，所以某處實際存在著對它的一個引用。這樣一來，垃圾收集器便只好對它“瞠目以對”了。

## 14.1.2 針對用戶界面的多線程

現在，我們也許能用一個線程解決在`Counter1.java`中出現的問題。採用的一個技巧便是在一個線程的`run()`方法中放置“子任務”——亦即位於`go()`內的循環。一旦用戶按下`Start`按鈕，線程就會啟動，但馬上結束線程的創建。這樣一來，儘管線程仍在運行，但程序的主要工作卻能得以繼續（等候並響應用戶界面的事件）。下面是具體的程式碼：

```
//: Counter2.java
// A responsive user interface with threads
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

class SeparateSubTask extends Thread {
  private int count = 0;
  private Counter2 c2;
  private boolean runFlag = true;
  public SeparateSubTask(Counter2 c2) {
    this.c2 = c2;
    start();
  }
  public void invertFlag() { runFlag = !runFlag;}
  public void run() {
    while (true) {
     try {
      sleep(100);
     } catch (InterruptedException e){}
     if(runFlag)
       c2.t.setText(Integer.toString(count++));
    }
  }
}

public class Counter2 extends Applet {
  TextField t = new TextField(10);
  private SeparateSubTask sp = null;
  private Button
    onOff = new Button("Toggle"),
    start = new Button("Start");
  public void init() {
    add(t);
    start.addActionListener(new StartL());
    add(start);
    onOff.addActionListener(new OnOffL());
    add(onOff);
  }
  class StartL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      if(sp == null)
        sp = new SeparateSubTask(Counter2.this);
    }
  }
  class OnOffL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      if(sp != null)
        sp.invertFlag();
    }
  }
  public static void main(String[] args) {
    Counter2 applet = new Counter2();
    Frame aFrame = new Frame("Counter2");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(300,200);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

現在，`Counter2`變成了一個相當直接的程序，它的唯一任務就是設置並管理用戶界面。但假若用戶現在按下`Start`按鈕，卻不會真正呼叫一個方法。此時不是創建類的一個線程，而是創建`SeparateSubTask`，然後繼續`Counter2`事件循環。注意此時會保存`SeparateSubTask`的引用，以便我們按下`onOff`按鈕的時候，能正常地切換位於`SeparateSubTask`內部的`runFlag`（運行標誌）。隨後那個線程便可啟動（當它看到標誌的時候），然後將自己中止（亦可將`SeparateSubTask`設為一個內部類來達到這一目的）。

`SeparateSubTask`類是對`Thread`的一個簡單擴展，它帶有一個構造器（其中保存了`Counter2`引用，然後通過呼叫`start()`來運行線程）以及一個`run()`——本質上包含了`Counter1.java`的`go()`內的程式碼。由於`SeparateSubTask`知道自己容納了指向一個`Counter2`的引用，所以能夠在需要的時候介入，並訪問`Counter2`的`TestField`（文本字段）。

按下`onOff`按鈕，幾乎立即能得到正確的響應。當然，這個響應其實並不是“立即”發生的，它畢竟和那種由“中斷”驅動的系統不同。只有線程擁有CPU的執行時間，並注意到標記已發生改變，計數器才會停止。

(1) 用內部類改善程式碼

下面說說題外話，請大家注意一下`SeparateSubTask`和`Counter2`類之間發生的結合行為。`SeparateSubTask`同`Counter2`“親密”地結合到了一起——它必須持有指向自己“父”`Counter2`物件的一個引用，以便自己能回調和操縱它。但兩個類並不是真的合併為單獨一個類（儘管在下一節中，我們會講到Java確實提供了合併它們的方法），因為它們各自做的是不同的事情，而且是在不同的時間創建的。但不管怎樣，它們依然緊密地結合到一起（更準確地說，應該叫“聯合”），所以使程序程式碼多少顯得有些笨拙。在這種情況下，一個內部類可以顯著改善程式碼的“可讀性”和執行效率：

```
//: Counter2i.java
// Counter2 using an inner class for the thread
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

public class Counter2i extends Applet {
  private class SeparateSubTask extends Thread {
    int count = 0;
    boolean runFlag = true;
    SeparateSubTask() { start(); }
    public void run() {
      while (true) {
       try {
        sleep(100);
       } catch (InterruptedException e){}
       if(runFlag)
         t.setText(Integer.toString(count++));
      }
    }
  }
  private SeparateSubTask sp = null;
  private TextField t = new TextField(10);
  private Button
    onOff = new Button("Toggle"),
    start = new Button("Start");
  public void init() {
    add(t);
    start.addActionListener(new StartL());
    add(start);
    onOff.addActionListener(new OnOffL());
    add(onOff);
  }
  class StartL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      if(sp == null)
        sp = new SeparateSubTask();
    }
  }
  class OnOffL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      if(sp != null)
        sp.runFlag = !sp.runFlag; // invertFlag();
    }
  }
  public static void main(String[] args) {
    Counter2i applet = new Counter2i();
    Frame aFrame = new Frame("Counter2i");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(300,200);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

這個`SeparateSubTask`名字不會與前例中的`SeparateSubTask`衝突——即使它們都在相同的目錄裡——因為它已作為一個內部類隱藏起來。大家亦可看到內部類被設為`private`（私有）屬性，這意味著它的字段和方法都可獲得默認的訪問權限（`run()`除外，它必須設為`public`，因為它在基類中是公開的）。除`Counter2i`之外，其他任何方面都不可訪問`private`內部類。而且由於兩個類緊密結合在一起，所以很容易放寬它們之間的訪問限制。在`SeparateSubTask`中，我們可看到`invertFlag()`方法已被刪去，因為`Counter2i`現在可以直接訪問`runFlag`。

此外，注意`SeparateSubTask`的構造器已得到了簡化——它現在唯一的用外就是啟動線程。`Counter2i`物件的引用仍象以前那樣得以捕獲，但不再是通過人工傳遞和引用外部物件來達到這一目的，此時的內部類機制可以自動照料它。在`run()`中，可看到對`t`的訪問是直接進行的，似乎它是`SeparateSubTask`的一個字段。父類中的t字段現在可以變成`private`，因為`SeparateSubTask`能在未獲任何特殊許可的前提下自由地訪問它——而且無論如何都該儘可能地把字段變成“私有”屬性，以防來自類外的某種力量不慎地改變它們。

無論在什麼時候，只要注意到類相互之間結合得比較緊密，就可考慮利用內部類來改善程式碼的編寫與維護。

## 14.1.3 用主類合併線程

在上面的例子中，我們看到線程類（`Thread`）與程序的主類（`Main`）是分隔開的。這樣做非常合理，而且易於理解。然而，還有另一種方式也是經常要用到的。儘管它不十分明確，但一般都要更簡潔一些（這也解釋了它為什麼十分流行）。通過將主程序類變成一個線程，這種形式可將主程序類與線程類合併到一起。由於對一個GUI程序來說，主程序類必須從`Frame`或`Applet`繼承，所以必須用一個接口加入額外的功能。這個接口叫作`Runnable`，其中包含了與`Thread`一致的基本方法。事實上，`Thread`也實作了`Runnable`，它只指出有一個`run()`方法。

對合並後的程序／線程來說，它的用法不是十分明確。當我們啟動程序時，會創建一個`Runnable`（可運行的）物件，但不會自行啟動線程。線程的啟動必須明確進行。下面這個程序向我們演示了這一點，它再現了`Counter2`的功能：

```
//: Counter3.java
// Using the Runnable interface to turn the
// main class into a thread.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

public class Counter3
    extends Applet implements Runnable {
  private int count = 0;
  private boolean runFlag = true;
  private Thread selfThread = null;
  private Button
    onOff = new Button("Toggle"),
    start = new Button("Start");
  private TextField t = new TextField(10);
  public void init() {
    add(t);
    start.addActionListener(new StartL());
    add(start);
    onOff.addActionListener(new OnOffL());
    add(onOff);
  }
  public void run() {
    while (true) {
      try {
        selfThread.sleep(100);
      } catch (InterruptedException e){}
      if(runFlag)
        t.setText(Integer.toString(count++));
    }
  }
  class StartL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      if(selfThread == null) {
        selfThread = new Thread(Counter3.this);
        selfThread.start();
      }
    }
  }
  class OnOffL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      runFlag = !runFlag;
    }
  }
  public static void main(String[] args) {
    Counter3 applet = new Counter3();
    Frame aFrame = new Frame("Counter3");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(300,200);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

現在`run()`位於類內，但它在`init()`結束以後仍處在“睡眠”狀態。若按下啟動按鈕，線程便會用多少有些曖昧的表達方式創建（若線程尚不存在）：

```
new Thread(Counter3.this);
```

若某樣東西有一個`Runnable`接口，實際只是意味著它有一個`run()`方法，但不存在與之相關的任何特殊東西——它不具有任何天生的線程處理能力，這與那些從`Thread`繼承的類是不同的。所以為了從一個`Runnable`物件產生線程，必須單獨創建一個線程，併為其傳遞`Runnable`物件；可為其使用一個特殊的構造器，並令其採用一個`Runnable`作為自己的參數使用。隨後便可為那個線程呼叫`start()`，如下所示：

```
selfThread.start();
```

它的作用是執行常規初始化操作，然後呼叫`run()`。

`Runnable`接口最大的一個優點是所有東西都從屬於相同的類。若需訪問什麼東西，只需簡單地訪問它即可，不需要涉及一個獨立的物件。但為這種便利也是要付出代價的——只可為那個特定的物件運行單獨一個線程（儘管可創建那種類型的多個物件，或者在不同的類裡創建其他物件）。

注意`Runnable`接口本身並不是造成這一限制的罪魁禍首。它是由於`Runnable`與我們的主類合併造成的，因為每個應用只能主類的一個物件。

## 14.1.4 製作多個線程

現在考慮一下創建多個不同的線程的問題。我們不可用前面的例子來做到這一點，所以必須倒退回去，利用從`Thread`繼承的多個獨立類來封裝`run()`。但這是一種更常規的方法，而且更易理解，所以儘管前例揭示了我們經常都能看到的編碼樣式，但並不推薦在大多數情況下都那樣做，因為它只是稍微複雜一些，而且靈活性稍低一些。

下面這個例子用計數器和切換按鈕再現了前面的編碼樣式。但這一次，一個特定計數器的所有信息（按鈕和文本字段）都位於它自己的、從`Thread`繼承的物件內。`Ticker`中的所有字段都具有`private`（私有）屬性，這意味著`Ticker`的具體實作方法可根據實際情況任意修改，其中包括修改用於獲取和顯示信息的數據組件的數量及類型。創建好一個`Ticker`物件以後，構造器便請求一個AWT容器（`Container`）的引用——`Ticker`用自己的可視組件填充那個容器。採用這種方式，以後一旦改變了可視組件，使用`Ticker`的程式碼便不需要另行修改一道。

```
//: Counter4.java
// If you separate your thread from the main
// class, you can have as many threads as you
// want.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

class Ticker extends Thread {
  private Button b = new Button("Toggle");
  private TextField t = new TextField(10);
  private int count = 0;
  private boolean runFlag = true;
  public Ticker(Container c) {
    b.addActionListener(new ToggleL());
    Panel p = new Panel();
    p.add(t);
    p.add(b);
    c.add(p);
  }
  class ToggleL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      runFlag = !runFlag;
    }
  }
  public void run() {
    while (true) {
      if(runFlag)
        t.setText(Integer.toString(count++));
       try {
        sleep(100);
      } catch (InterruptedException e){}
    }
  }
}

public class Counter4 extends Applet {
  private Button start = new Button("Start");
  private boolean started = false;
  private Ticker[] s;
  private boolean isApplet = true;
  private int size;
  public void init() {
    // Get parameter "size" from Web page:
    if(isApplet)
      size =
        Integer.parseInt(getParameter("size"));
    s = new Ticker[size];
    for(int i = 0; i < s.length; i++)
      s[i] = new Ticker(this);
    start.addActionListener(new StartL());
    add(start);
  }
  class StartL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      if(!started) {
        started = true;
        for(int i = 0; i < s.length; i++)
          s[i].start();
      }
    }
  }
  public static void main(String[] args) {
    Counter4 applet = new Counter4();
    // This isn't an applet, so set the flag and
    // produce the parameter values from args:
    applet.isApplet = false;
    applet.size =
      (args.length == 0 ? 5 :
        Integer.parseInt(args[0]));
    Frame aFrame = new Frame("Counter4");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(200, applet.size * 50);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

`Ticker`不僅包括了自己的線程處理機制，也提供了控制與顯示線程的工具。可按自己的意願創建任意數量的線程，毋需明確地創建窗口化組件。

在`Counter4`中，有一個名為`s`的`Ticker`物件的數組。為獲得最大的靈活性，這個數組的長度是用程序片參數接觸Web頁而初始化的。下面是網頁中長度參數大致的樣子，它們嵌於對程序片（applet）的描述內容中：

```
<applet code=Counter4 width=600 height=600>
<param name=size value="20">
</applet>
```

其中，`param`，`name`和`value`是所有Web頁都適用的關鍵字。`name`是指程序中對參數的一種引用稱謂，`value`可以是任何字符串（並不僅僅是解析成一個數字的東西）。

我們注意到對數組`s`長度的判斷是在`init()`內部完成的，它沒有作為`s`的內嵌定義的一部分提供。換言之，不可將下述程式碼作為類定義的一部分使用（應該位於任何方法的外部）：

```
inst size = Integer.parseInt(getParameter("Size"));
Ticker[] s = new Ticker[size]
```

可把它編譯出來，但會在運行期得到一個空指針異常。但若將`getParameter()`初始化移入`init()`，則可正常工作。程序片框架會進行必要的啟動工作，以便在進入`init()`前收集好一些參數。

此外，上述程式碼被同時設置成一個程序片和一個應用（程序）。在它是應用程序的情況下，`size`參數可從命令行裡提取出來（否則就提供一個默認的值）。

數組的長度建好以後，就可以創建新的`Ticker`物件；作為`Ticker`構造器的一部分，用於每個`Ticker`的按鈕和文本字段就會加入程序片。

按下`Start`按鈕後，會在整個`Ticker`數組裡遍歷，併為每個`Ticker`呼叫`start()`。記住，`start()`會進行必要的線程初始化工作，然後為那個線程呼叫`run()`。

`ToggleL`監視器只是簡單地切換`Ticker`中的標記，一旦對應線程以後需要修改這個標記，它會作出相應的反應。

這個例子的一個好處是它使我們能夠方便地創建由單獨子任務構成的大型集合，並以監視它們的行為。在這種情況下，我們會發現隨著子任務數量的增多，機器顯示出來的數字可能會出現更大的分歧，這是由於為線程提供服務的方式造成的。

亦可試著體驗一下`sleep(100)`在`Ticker.run()`中的重要作用。若刪除`sleep()`，那麼在按下一個切換按鈕前，情況仍然會進展良好。按下按鈕以後，那個特定的線程就會出現一個失敗的`runFlag`，而且`run()`會深深地陷入一個無限循環——很難在多任務處理期間中止退出。因此，程序對用戶操作的反應靈敏度會大幅度降低。

## 14.1.5 Daemon線程

“Daemon”線程的作用是在程序的運行期間於後臺提供一種“常規”服務，但它並不屬於程序的一個基本部分。因此，一旦所有非Daemon線程完成，程序也會中止運行。相反，假若有任何非Daemon線程仍在運行（比如還有一個正在運行`main()`的線程），則程序的運行不會中止。

通過呼叫`isDaemon()`，可調查一個線程是不是一個Daemon，而且能用`setDaemon()`打開或者關閉一個線程的Daemon狀態。如果是一個Daemon線程，那麼它創建的任何線程也會自動具備Daemon屬性。

下面這個例子演示了Daemon線程的用法：

```
//: Daemons.java
// Daemonic behavior
import java.io.*;

class Daemon extends Thread {
  private static final int SIZE = 10;
  private Thread[] t = new Thread[SIZE];
  public Daemon() {
    setDaemon(true);
    start();
  }
  public void run() {
    for(int i = 0; i < SIZE; i++)
      t[i] = new DaemonSpawn(i);
    for(int i = 0; i < SIZE; i++)
      System.out.println(
        "t[" + i + "].isDaemon() = "
        + t[i].isDaemon());
    while(true)
      yield();
  }
}

class DaemonSpawn extends Thread {
  public DaemonSpawn(int i) {
    System.out.println(
      "DaemonSpawn " + i + " started");
    start();
  }
  public void run() {
    while(true)
      yield();
  }
}

public class Daemons {
  public static void main(String[] args) {
    Thread d = new Daemon();
    System.out.println(
      "d.isDaemon() = " + d.isDaemon());
    // Allow the daemon threads to finish
    // their startup processes:
    BufferedReader stdin =
      new BufferedReader(
        new InputStreamReader(System.in));
    System.out.println("Waiting for CR");
    try {
      stdin.readLine();
    } catch(IOException e) {}
  }
} ///:~
```

Daemon線程可將自己的Daemon標記設置成“真”，然後產生一系列其他線程，而且認為它們也具有Daemon屬性。隨後，它進入一個無限循環，在其中呼叫`yield()`，放棄對其他進程的控制。在這個程序早期的一個版本中，無限循環會使`int`計數器自增，但會使整個程序都好象陷入停頓狀態。換用`yield()`後，卻可使程序充滿“活力”，不會使人產生停滯或反應遲鈍的感覺。

一旦`main()`完成自己的工作，便沒有什麼能阻止程序中斷運行，因為這裡運行的只有Daemon線程。所以能看到啟動所有Daemon線程後顯示出來的結果，`System.in`也進行了相應的設置，使程序中斷前能等待一個回車。如果不進行這樣的設置，就只能看到創建Daemon線程的一部分結果（試試將`readLine()`程式碼換成不同長度的`sleep()`呼叫，看看會有什麼表現）。


# 14.2 共享有限的資源


可將單線程程序想象成一種孤立的實體，它能遍歷我們的問題空間，而且一次只能做一件事情。由於只有一個實體，所以永遠不必擔心會有兩個實體同時試圖使用相同的資源，就象兩個人同時都想停到一個車位，同時都想通過一扇門，甚至同時發話。

進入多線程環境後，它們則再也不是孤立的。可能會有兩個甚至更多的線程試圖同時同一個有限的資源。必須對這種潛在資源衝突進行預防，否則就可能發生兩個線程同時訪問一個銀行帳號，打印到同一臺計算機，以及對同一個值進行調整等等。

## 14.2.1 資源訪問的錯誤方法

現在考慮換成另一種方式來使用本章頻繁見到的計數器。在下面的例子中，每個線程都包含了兩個計數器，它們在`run()`裡自增以及顯示。除此以外，我們使用了`Watcher`類的另一個線程。它的作用是監視計數器，檢查它們是否保持相等。這表面是一項無意義的行動，因為如果查看程式碼，就會發現計數器肯定是相同的。但實際情況卻不一定如此。下面是程序的第一個版本：

```
//: Sharing1.java
// Problems with resource sharing while threading
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

class TwoCounter extends Thread {
  private boolean started = false;
  private TextField
    t1 = new TextField(5),
    t2 = new TextField(5);
  private Label l =
    new Label("count1 == count2");
  private int count1 = 0, count2 = 0;
  // Add the display components as a panel
  // to the given container:
  public TwoCounter(Container c) {
    Panel p = new Panel();
    p.add(t1);
    p.add(t2);
    p.add(l);
    c.add(p);
  }
  public void start() {
    if(!started) {
      started = true;
      super.start();
    }
  }
  public void run() {
    while (true) {
      t1.setText(Integer.toString(count1++));
      t2.setText(Integer.toString(count2++));
      try {
        sleep(500);
      } catch (InterruptedException e){}
    }
  }
  public void synchTest() {
    Sharing1.incrementAccess();
    if(count1 != count2)
      l.setText("Unsynched");
  }
}

class Watcher extends Thread {
  private Sharing1 p;
  public Watcher(Sharing1 p) {
    this.p = p;
    start();
  }
  public void run() {
    while(true) {
      for(int i = 0; i < p.s.length; i++)
        p.s[i].synchTest();
      try {
        sleep(500);
      } catch (InterruptedException e){}
    }
  }
}

public class Sharing1 extends Applet {
  TwoCounter[] s;
  private static int accessCount = 0;
  private static TextField aCount =
    new TextField("0", 10);
  public static void incrementAccess() {
    accessCount++;
    aCount.setText(Integer.toString(accessCount));
  }
  private Button
    start = new Button("Start"),
    observer = new Button("Observe");
  private boolean isApplet = true;
  private int numCounters = 0;
  private int numObservers = 0;
  public void init() {
    if(isApplet) {
      numCounters =
        Integer.parseInt(getParameter("size"));
      numObservers =
        Integer.parseInt(
          getParameter("observers"));
    }
    s = new TwoCounter[numCounters];
    for(int i = 0; i < s.length; i++)
      s[i] = new TwoCounter(this);
    Panel p = new Panel();
    start.addActionListener(new StartL());
    p.add(start);
    observer.addActionListener(new ObserverL());
    p.add(observer);
    p.add(new Label("Access Count"));
    p.add(aCount);
    add(p);
  }
  class StartL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      for(int i = 0; i < s.length; i++)
        s[i].start();
    }
  }
  class ObserverL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      for(int i = 0; i < numObservers; i++)
        new Watcher(Sharing1.this);
    }
  }
  public static void main(String[] args) {
    Sharing1 applet = new Sharing1();
    // This isn't an applet, so set the flag and
    // produce the parameter values from args:
    applet.isApplet = false;
    applet.numCounters =
      (args.length == 0 ? 5 :
        Integer.parseInt(args[0]));
    applet.numObservers =
      (args.length < 2 ? 5 :
        Integer.parseInt(args[1]));
    Frame aFrame = new Frame("Sharing1");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e){
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(350, applet.numCounters *100);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

和往常一樣，每個計數器都包含了自己的顯示組件：兩個文本字段以及一個標籤。根據它們的初始值，可知道計數是相同的。這些組件在`TwoCounter`構造器加入`Container`。由於這個線程是通過用戶的一個“按下按鈕”操作啟動的，所以`start()`可能被多次呼叫。但對一個線程來說，對`Thread.start()`的多次呼叫是非法的（會產生異常）。在`started`標記和重載的`start()`方法中，大家可看到針對這一情況採取的防範措施。

在`run()`中，`count1`和`count2`的自增與顯示方式表面上似乎能保持它們完全一致。隨後會呼叫`sleep()`；若沒有這個呼叫，程序便會出錯，因為那會造成CPU難於交換任務。

`synchTest()`方法採取的似乎是沒有意義的行動，它檢查`count1`是否等於`count2`；如果不等，就把標籤設為`"Unsynched"`（不同步）。但是首先，它呼叫的是類`Sharing1`的一個靜態成員，以便自增和顯示一個訪問計數器，指出這種檢查已成功進行了多少次（這樣做的理由會在本例的其他版本中變得非常明顯）。

`Watcher`類是一個線程，它的作用是為處於活動狀態的所有`TwoCounter`物件都呼叫`synchTest()`。其間，它會對`Sharing1`物件中容納的數組進行遍歷。可將`Watcher`想象成它掠過`TwoCounter`物件的肩膀不斷地“偷看”。

`Sharing1`包含了`TwoCounter`物件的一個數組，它通過`init()`進行初始化，並在我們按下`"start"`按鈕後作為線程啟動。以後若按下`"Observe"`（觀察）按鈕，就會創建一個或者多個觀察器，並對毫不設防的`TwoCounter`進行調查。

注意為了讓它作為一個程序片在瀏覽器中運行，Web頁需要包含下面這幾行：

```
<applet code=Sharing1 width=650 height=500>
<param name=size value="20">
<param name=observers value="1">
</applet>
```

可自行改變寬度、高度以及參數，根據自己的意願進行試驗。若改變了`size`和`observers`，程序的行為也會發生變化。我們也注意到，通過從命令行接受參數（或者使用默認值），它被設計成作為一個獨立的應用程序運行。

下面才是最讓人“不可思議”的。在`TwoCounter.run()`中，無限循環只是不斷地重複相鄰的行：

```
t1.setText(Integer.toString(count1++));
t2.setText(Integer.toString(count2++));
```

（和“睡眠”一樣，不過在這裡並不重要）。但在程序運行的時候，你會發現`count1`和`count2`被“觀察”（用`Watcher`觀察）的次數是不相等的！這是由線程的本質造成的——它們可在任何時候掛起（暫停）。所以在上述兩行的執行時刻之間，有時會出現執行暫停現象。同時，`Watcher`線程也正好跟隨著進來，並正好在這個時候進行比較，造成計數器出現不相等的情況。

本例揭示了使用線程時一個非常基本的問題。我們跟無從知道一個線程什麼時候運行。想象自己坐在一張桌子前面，桌上放有一把叉子，準備叉起自己的最後一塊食物。當叉子要碰到食物時，食物卻突然消失了（因為這個線程已被掛起，同時另一個線程進來“偷”走了食物）。這便是我們要解決的問題。

有的時候，我們並不介意一個資源在嘗試使用它的時候是否正被訪問（食物在另一些盤子裡）。但為了讓多線程機制能夠正常運轉，需要採取一些措施來防止兩個線程訪問相同的資源——至少在關鍵的時期。

為防止出現這樣的衝突，只需在線程使用一個資源時為其加鎖即可。訪問資源的第一個線程會其加上鎖以後，其他線程便不能再使用那個資源，除非被解鎖。如果車子的前座是有限的資源，高喊“這是我的！”的孩子會主張把它鎖起來。

## 14.2.2 Java如何共享資源

對一種特殊的資源——物件中的內存——Java提供了內建的機制來防止它們的衝突。由於我們通常將數據元素設為從屬於`private`（私有）類，然後只通過方法訪問那些內存，所以只需將一個特定的方法設為`synchronized`（同步的），便可有效地防止衝突。在任何時刻，只可有一個線程呼叫特定物件的一個`synchronized`方法（儘管那個線程可以呼叫多個物件的同步方法）。下面列出簡單的s`ynchronized`方法：


```
synchronized void f() { /* ... */ }
synchronized void g() { /* ... */ }
```

每個物件都包含了一把鎖（也叫作“監視器”），它自動成為物件的一部分（不必為此寫任何特殊的程式碼）。呼叫任何`synchronized`方法時，物件就會被鎖定，不可再呼叫那個物件的其他任何`synchronized`方法，除非第一個方法完成了自己的工作，並解除鎖定。在上面的例子中，如果為一個物件呼叫`f()`，便不能再為同樣的物件呼叫`g()`，除非`f()`完成並解除鎖定。因此，一個特定物件的所有`synchronized`方法都共享著一把鎖，而且這把鎖能防止多個方法對通用內存同時進行寫操作（比如同時有多個線程）。

每個類也有自己的一把鎖（作為類的`Class`物件的一部分），所以`synchronized static`方法可在一個類的範圍內被相互間鎖定起來，防止與`static`數據的接觸。

注意如果想保護其他某些資源不被多個線程同時訪問，可以強制通過`synchronized`方訪問那些資源。

(1) 計數器的同步

裝備了這個新關鍵字後，我們能夠採取的方法就更靈活了：可以只為`TwoCounter`中的方法簡單地使用`synchronized`關鍵字。下面這個例子是對前例的改版，其中加入了新的關鍵字：

```
//: Sharing2.java
// Using the synchronized keyword to prevent
// multiple access to a particular resource.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

class TwoCounter2 extends Thread {
  private boolean started = false;
  private TextField
    t1 = new TextField(5),
    t2 = new TextField(5);
  private Label l =
    new Label("count1 == count2");
  private int count1 = 0, count2 = 0;
  public TwoCounter2(Container c) {
    Panel p = new Panel();
    p.add(t1);
    p.add(t2);
    p.add(l);
    c.add(p);
  }    
  public void start() {
    if(!started) {
      started = true;
      super.start();
    }
  }
  public synchronized void run() {
    while (true) {
      t1.setText(Integer.toString(count1++));
      t2.setText(Integer.toString(count2++));
      try {
        sleep(500);
      } catch (InterruptedException e){}
    }
  }
  public synchronized void synchTest() {
    Sharing2.incrementAccess();
    if(count1 != count2)
      l.setText("Unsynched");
  }
}

class Watcher2 extends Thread {
  private Sharing2 p;
  public Watcher2(Sharing2 p) {
    this.p = p;
    start();
  }
  public void run() {
    while(true) {
      for(int i = 0; i < p.s.length; i++)
        p.s[i].synchTest();
      try {
        sleep(500);
      } catch (InterruptedException e){}
    }
  }
}

public class Sharing2 extends Applet {
  TwoCounter2[] s;
  private static int accessCount = 0;
  private static TextField aCount =
    new TextField("0", 10);
  public static void incrementAccess() {
    accessCount++;
    aCount.setText(Integer.toString(accessCount));
  }
  private Button
    start = new Button("Start"),
    observer = new Button("Observe");
  private boolean isApplet = true;
  private int numCounters = 0;
  private int numObservers = 0;
  public void init() {
    if(isApplet) {
      numCounters =
        Integer.parseInt(getParameter("size"));
      numObservers =
        Integer.parseInt(
          getParameter("observers"));
    }
    s = new TwoCounter2[numCounters];
    for(int i = 0; i < s.length; i++)
      s[i] = new TwoCounter2(this);
    Panel p = new Panel();
    start.addActionListener(new StartL());
    p.add(start);
    observer.addActionListener(new ObserverL());
    p.add(observer);
    p.add(new Label("Access Count"));
    p.add(aCount);
    add(p);
  }
  class StartL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      for(int i = 0; i < s.length; i++)
        s[i].start();
    }
  }
  class ObserverL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      for(int i = 0; i < numObservers; i++)
        new Watcher2(Sharing2.this);
    }
  }
  public static void main(String[] args) {
    Sharing2 applet = new Sharing2();
    // This isn't an applet, so set the flag and
    // produce the parameter values from args:
    applet.isApplet = false;
    applet.numCounters =
      (args.length == 0 ? 5 :
        Integer.parseInt(args[0]));
    applet.numObservers =
      (args.length < 2 ? 5 :
        Integer.parseInt(args[1]));
    Frame aFrame = new Frame("Sharing2");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e){
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(350, applet.numCounters *100);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

我們注意到無論`run()`還是`synchTest()`都是“同步的”。如果只同步其中的一個方法，那麼另一個就可以自由忽視物件的鎖定，並可無礙地呼叫。所以必須記住一個重要的規則：對於訪問某個關鍵共享資源的所有方法，都必須把它們設為`synchronized`，否則就不能正常地工作。

現在又遇到了一個新問題。`Watcher2`永遠都不能看到正在進行的事情，因為整個`run()`方法已設為“同步”。而且由於肯定要為每個物件運行`run()`，所以鎖永遠不能打開，而`synchTest()`永遠不會得到呼叫。之所以能看到這一結果，是因為`accessCount`根本沒有變化。

為解決這個問題，我們能採取的一個辦法是隻將`run()`中的一部分程式碼隔離出來。想用這個辦法隔離出來的那部分程式碼叫作“關鍵區域”，而且要用不同的方式來使用`synchronized`關鍵字，以設置一個關鍵區域。Java通過“同步塊”提供對關鍵區域的支持；這一次，我們用`synchronized`關鍵字指出物件的鎖用於對其中封閉的程式碼進行同步。如下所示：

```
synchronized(syncObject) {
  // This code can be accessed by only
  // one thread at a time, assuming all
  // threads respect syncObject's lock
}
```

在能進入同步塊之前，必須在`synchObject`上取得鎖。如果已有其他線程取得了這把鎖，塊便不能進入，必須等候那把鎖被釋放。

可從整個`run()`中刪除`synchronized`關鍵字，換成用一個同步塊包圍兩個關鍵行，從而完成對`Sharing2`例子的修改。但什麼物件應作為鎖來使用呢？那個物件已由`synchTest()`標記出來了——也就是當前物件（`this`）！所以修改過的`run()`方法象下面這個樣子：

```
  public void run() {
    while (true) {
      synchronized(this) {
        t1.setText(Integer.toString(count1++));
        t2.setText(Integer.toString(count2++));
      }
      try {
        sleep(500);
      } catch (InterruptedException e){}
    }
  }
```

這是必須對`Sharing2.java`作出的唯一修改，我們會看到儘管兩個計數器永遠不會脫離同步（取決於允許`Watcher`什麼時候檢查它們），但在`run()`執行期間，仍然向`Watcher`提供了足夠的訪問權限。

當然，所有同步都取決於程序員是否勤奮：要訪問共享資源的每一部分程式碼都必須封裝到一個適當的同步塊裡。

(2) 同步的效率

由於要為同樣的數據編寫兩個方法，所以無論如何都不會給人留下效率很高的印象。看來似乎更好的一種做法是將所有方法都設為自動同步，並完全消除`synchronized`關鍵字（當然，含有`synchronized run()`的例子顯示出這樣做是很不通的）。但它也揭示出獲取一把鎖並非一種“廉價”方法——為一次方法呼叫付出的代價（進入和退出方法，不執行方法主體）至少要累加到四倍，而且根據我們的具體現方法，這一代價還有可能變得更高。所以假如已知一個方法不會造成衝突，最明智的做法便是撤消其中的`synchronized`關鍵字。

## 14.2.3 回顧Java Beans

我們現在已理解了同步，接著可換從另一個角度來考察Java Beans。無論什麼時候創建了一個Bean，就必須假定它要在一個多線程的環境中運行。這意味著：

(1) 只要可行，Bean的所有公共方法都應同步。當然，這也帶來了“同步”在運行期間的開銷。若特別在意這個問題，在關鍵區域中不會造成問題的方法就可保留為“不同步”，但注意這通常都不是十分容易判斷。有資格的方法傾向於規模很小（如下例的`getCircleSize()`）以及／或者“微小”。也就是說，這個方法呼叫在如此少的程式碼片裡執行，以至於在執行期間物件不能改變。如果將這種方法設為“不同步”，可能對程序的執行速度不會有明顯的影響。可能也將一個Bean的所有`public`方法都設為`synchronized`，並只有在保證特別必要、而且會造成一個差異的情況下，才將`synchronized`關鍵字刪去。

(2) 如果將一個多轉換事件送給一系列對那個事件感興趣的“聽眾”，必須假在列表中移動的時候可以添加或者刪除。

第一點很容易處理，但第二點需要考慮更多的東西。讓我們以前一章提供的`BangBean.java`為例。在那個例子中，我們忽略了`synchronized`關鍵字（那時還沒有引入呢），並將轉換設為單轉換，從而回避了多線程的問題。在下面這個修改過的版本中，我們使其能在多線程環境中工作，併為事件採用了多轉換技術：

```
//: BangBean2.java
// You should write your Beans this way so they
// can run in a multithreaded environment.
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.io.*;

public class BangBean2 extends Canvas
    implements Serializable {
  private int xm, ym;
  private int cSize = 20; // Circle size
  private String text = "Bang!";
  private int fontSize = 48;
  private Color tColor = Color.red;
  private Vector actionListeners = new Vector();
  public BangBean2() {
    addMouseListener(new ML());
    addMouseMotionListener(new MM());
  }
  public synchronized int getCircleSize() {
    return cSize;
  }
  public synchronized void
  setCircleSize(int newSize) {
    cSize = newSize;
  }
  public synchronized String getBangText() {
    return text;
  }
  public synchronized void
  setBangText(String newText) {
    text = newText;
  }
  public synchronized int getFontSize() {
    return fontSize;
  }
  public synchronized void
  setFontSize(int newSize) {
    fontSize = newSize;
  }
  public synchronized Color getTextColor() {
    return tColor;
  }
  public synchronized void
  setTextColor(Color newColor) {
    tColor = newColor;
  }
  public void paint(Graphics g) {
    g.setColor(Color.black);
    g.drawOval(xm - cSize/2, ym - cSize/2,
      cSize, cSize);
  }
  // This is a multicast listener, which is
  // more typically used than the unicast
  // approach taken in BangBean.java:
  public synchronized void addActionListener (
      ActionListener l) {
    actionListeners.addElement(l);
  }
  public synchronized void removeActionListener(
      ActionListener l) {
    actionListeners.removeElement(l);
  }
  // Notice this isn't synchronized:
  public void notifyListeners() {
    ActionEvent a =
      new ActionEvent(BangBean2.this,
        ActionEvent.ACTION_PERFORMED, null);
    Vector lv = null;
    // Make a copy of the vector in case someone
    // adds a listener while we're
    // calling listeners:
    synchronized(this) {
      lv = (Vector)actionListeners.clone();
    }
    // Call all the listener methods:
    for(int i = 0; i < lv.size(); i++) {
      ActionListener al =
        (ActionListener)lv.elementAt(i);
      al.actionPerformed(a);
    }
  }
  class ML extends MouseAdapter {
    public void mousePressed(MouseEvent e) {
      Graphics g = getGraphics();
      g.setColor(tColor);
      g.setFont(
        new Font(
          "TimesRoman", Font.BOLD, fontSize));
      int width =
        g.getFontMetrics().stringWidth(text);
      g.drawString(text,
        (getSize().width - width) /2,
        getSize().height/2);
      g.dispose();
      notifyListeners();
    }
  }
  class MM extends MouseMotionAdapter {
    public void mouseMoved(MouseEvent e) {
      xm = e.getX();
      ym = e.getY();
      repaint();
    }
  }
  // Testing the BangBean2:
  public static void main(String[] args) {
    BangBean2 bb = new BangBean2();
    bb.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e){
        System.out.println("ActionEvent" + e);
      }
    });
    bb.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e){
        System.out.println("BangBean2 action");
      }
    });
    bb.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e){
        System.out.println("More action");
      }
    });
    Frame aFrame = new Frame("BangBean2 Test");
    aFrame.addWindowListener(new WindowAdapter(){
      public void windowClosing(WindowEvent e) {
        System.exit(0);
      }
    });
    aFrame.add(bb, BorderLayout.CENTER);
    aFrame.setSize(300,300);
    aFrame.setVisible(true);
  }
} ///:~
```

很容易就可以為方法添加`synchronized`。但注意在`addActionListener()`和`removeActionListener()`中，現在添加了`ActionListener`，並從一個`Vector`中移去，所以能夠根據自己願望使用任意多個。

我們注意到，`notifyListeners()`方法並未設為“同步”。可從多個線程中發出對這個方法的呼叫。另外，在對`notifyListeners()`呼叫的中途，也可能發出對`addActionListener()`和`removeActionListener()`的呼叫。這顯然會造成問題，因為它否定了`Vector actionListeners`。為緩解這個問題，我們在一個`synchronized`從句中“克隆”了`Vector`，並對克隆進行了否定。這樣便可在不影響`notifyListeners()`的前提下，對`Vector`進行操縱。

`paint()`方法也沒有設為“同步”。與單純地添加自己的方法相比，決定是否對重載的方法進行同步要困難得多。在這個例子中，無論`paint()`是否“同步”，它似乎都能正常地工作。但必須考慮的問題包括：

(1) 方法會在物件內部修改“關鍵”變量的狀態嗎？為判斷一個變量是否“關鍵”，必須知道它是否會被程序中的其他線程讀取或設置（就目前的情況看，讀取或設置幾乎肯定是通過“同步”方法進行的，所以可以只對它們進行檢查）。對`paint()`的情況來說，不會發生任何修改。

(2) 方法要以這些“關鍵”變量的狀態為基礎嗎？如果一個“同步”方法修改了一個變量，而我們的方法要用到這個變量，那麼一般都願意把自己的方法也設為“同步”。基於這一前提，大家可觀察到`cSize`由“同步”方法進行了修改，所以`paint()`應當是“同步”的。但在這裡，我們可以問：“假如`cSize`在`paint()`執行期間發生了變化，會發生的最糟糕的事情是什麼呢？”如果發現情況不算太壞，而且僅僅是暫時的效果，那麼最好保持`paint()`的“不同步”狀態，以避免同步方法呼叫帶來的額外開銷。

(3) 要留意的第三條線索是`paint()`基類版本是否“同步”，在這裡它不是同步的。這並不是一個非常嚴格的參數，僅僅是一條“線索”。比如在目前的情況下，通過同步方法（好`cSize`）改變的一個字段已組合到`paint()`公式裡，而且可能已改變了情況。但請注意，`synchronized`不能繼承——也就是說，假如一個方法在基類中是“同步”的，那麼在派生類重載版本中，它不會自動進入“同步”狀態。

`TestBangBean2`中的測試程式碼已在前一章的基礎上進行了修改，已在其中加入了額外的“聽眾”，從而演示了`BangBean2`的多轉換能力。


# 14.3 堵塞


一個線程可以有四種狀態：

(1) 新（New）：線程物件已經創建，但尚未啟動，所以不可運行。

(2) 可運行（Runnable）：意味著一旦時間分片機制有空閒的CPU週期提供給一個線程，那個線程便可立即開始運行。因此，線程可能在、也可能不在運行當中，但一旦條件許可，沒有什麼能阻止它的運行——它既沒有“死”掉，也未被“堵塞”。

(3) 死（Dead）：從自己的`run()`方法中返回後，一個線程便已“死”掉。亦可呼叫`stop()`令其死掉，但會產生一個異常——屬於`Error`的一個子類（也就是說，我們通常不捕獲它）。記住一個異常的“拋”出應當是一個特殊事件，而不是正常程序運行的一部分。所以不建議你使用`stop()`（在Java 1.2則是堅決反對）。另外還有一個`destroy()`方法（它永遠不會實作），應該儘可能地避免呼叫它，因為它非常武斷，根本不會解除物件的鎖定。

(4) 堵塞（Blocked）：線程可以運行，但有某種東西阻礙了它。若線程處於堵塞狀態，調度機制可以簡單地跳過它，不給它分配任何CPU時間。除非線程再次進入“可運行”狀態，否則不會採取任何操作。

## 14.3.1 為何會堵塞

堵塞狀態是前述四種狀態中最有趣的，值得我們作進一步的探討。線程被堵塞可能是由下述五方面的原因造成的：

(1) 呼叫`sleep(毫秒數)`，使線程進入“睡眠”狀態。在規定的時間內，這個線程是不會運行的。

(2) 用`suspend()`暫停了線程的執行。除非線程收到`resume()`訊息，否則不會返回“可運行”狀態。

(3) 用`wait()`暫停了線程的執行。除非線程收到`nofify()`或者`notifyAll()`訊息，否則不會變成“可運行”（是的，這看起來同原因2非常相象，但有一個明顯的區別是我們馬上要揭示的）。

(4) 線程正在等候一些IO（輸入輸出）操作完成。

(5) 線程試圖呼叫另一個物件的“同步”方法，但那個物件處於鎖定狀態，暫時無法使用。

亦可呼叫`yield()`（`Thread`類的一個方法）自動放棄CPU，以便其他線程能夠運行。然而，假如調度機制覺得我們的線程已擁有足夠的時間，並跳轉到另一個線程，就會發生同樣的事情。也就是說，沒有什麼能防止調度機制重新啟動我們的線程。線程被堵塞後，便有一些原因造成它不能繼續運行。

下面這個例子展示了進入堵塞狀態的全部五種途徑。它們全都存在於名為`Blocking.java`的一個文件中，但在這兒採用散落的片斷進行解釋（大家可注意到片斷前後的`Continued`以及`Continuing`標誌。利用第17章介紹的工具，可將這些片斷連結到一起）。首先讓我們看看基本的框架：

```
//: Blocking.java
// Demonstrates the various ways a thread
// can be blocked.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
import java.io.*;

//////////// The basic framework ///////////
class Blockable extends Thread {
  private Peeker peeker;
  protected TextField state = new TextField(40);
  protected int i;
  public Blockable(Container c) {
    c.add(state);
    peeker = new Peeker(this, c);
  }
  public synchronized int read() { return i; }
  protected synchronized void update() {
    state.setText(getClass().getName()
      + " state: i = " + i);
  }
  public void stopPeeker() {
    // peeker.stop(); Deprecated in Java 1.2
    peeker.terminate(); // The preferred approach
  }
}

class Peeker extends Thread {
  private Blockable b;
  private int session;
  private TextField status = new TextField(40);
  private boolean stop = false;
  public Peeker(Blockable b, Container c) {
    c.add(status);
    this.b = b;
    start();
  }
  public void terminate() { stop = true; }
  public void run() {
    while (!stop) {
      status.setText(b.getClass().getName()
        + " Peeker " + (++session)
        + "; value = " + b.read());
       try {
        sleep(100);
      } catch (InterruptedException e){}
    }
  }
} ///:Continued
```

`Blockable`類打算成為本例所有類的一個基類。一個`Blockable`物件包含了一個名為`state`的`TextField`（文本字段），用於顯示出物件有關的信息。用於顯示這些信息的方法叫作`update()`。我們發現它用`getClass.getName()`來產生類名，而不是僅僅把它打印出來；這是由於`update(0)`不知道自己為其呼叫的那個類的準確名字，因為那個類是從`Blockable`派生出來的。

在`Blockable`中，變動指示符是一個`int i`；派生類的`run()`方法會為其自增。

針對每個`Bloackable`物件，都會啟動`Peeker`類的一個線程。`Peeker`的任務是呼叫`read()`方法，檢查與自己關聯的`Blockable`物件，看看i是否發生了變化，最後用它的`status`文本字段報告檢查結果。注意`read()`和`update()`都是同步的，要求物件的鎖定能自由解除，這一點非常重要。

(1) 睡眠


這個程序的第一項測試是用`sleep()`作出的：

```
///:Continuing
///////////// Blocking via sleep() ///////////
class Sleeper1 extends Blockable {
  public Sleeper1(Container c) { super(c); }
  public synchronized void run() {
    while(true) {
      i++;
      update();
       try {
        sleep(1000);
      } catch (InterruptedException e){}
    }
  }
}

class Sleeper2 extends Blockable {
  public Sleeper2(Container c) { super(c); }
  public void run() {
    while(true) {
      change();
       try {
        sleep(1000);
      } catch (InterruptedException e){}
    }
  }
  public synchronized void change() {
      i++;
      update();
  }
} ///:Continued
```

在`Sleeper1`中，整個`run()`方法都是同步的。我們可看到與這個物件關聯在一起的`Peeker`可以正常運行，直到我們啟動線程為止，隨後`Peeker`便會完全停止。這正是“堵塞”的一種形式：因為`Sleeper1.run()`是同步的，而且一旦線程啟動，它就肯定在`run()`內部，方法永遠不會放棄物件鎖定，造成`Peeker`線程的堵塞。

`Sleeper2`通過設置不同步的運行，提供了一種解決方法。只有`change()`方法才是同步的，所以儘管`run()`位於`sleep()`內部，`Peeker`仍然能訪問自己需要的同步方法——`read()`。在這裡，我們可看到在啟動了`Sleeper2`線程以後，`Peeker`會持續運行下去。

(2) 暫停和恢復

這個例子接下來的一部分引入了“掛起”或者“暫停”（`Suspend`）的概述。`Thread`類提供了一個名為`suspend()`的方法，可臨時中止線程；以及一個名為`resume()`的方法，用於從暫停處開始恢復線程的執行。顯然，我們可以推斷出`resume()`是由暫停線程外部的某個線程呼叫的。在這種情況下，需要用到一個名為`Resumer`（恢復器）的獨立類。演示暫停／恢復過程的每個類都有一個相關的恢復器。如下所示：

```
///:Continuing
/////////// Blocking via suspend() ///////////
class SuspendResume extends Blockable {
  public SuspendResume(Container c) {
    super(c);    
    new Resumer(this);
  }
}

class SuspendResume1 extends SuspendResume {
  public SuspendResume1(Container c) { super(c);}
  public synchronized void run() {
    while(true) {
      i++;
      update();
      suspend(); // Deprecated in Java 1.2
    }
  }
}

class SuspendResume2 extends SuspendResume {
  public SuspendResume2(Container c) { super(c);}
  public void run() {
    while(true) {
      change();
      suspend(); // Deprecated in Java 1.2
    }
  }
  public synchronized void change() {
      i++;
      update();
  }
}

class Resumer extends Thread {
  private SuspendResume sr;
  public Resumer(SuspendResume sr) {
    this.sr = sr;
    start();
  }
  public void run() {
    while(true) {
       try {
        sleep(1000);
      } catch (InterruptedException e){}
      sr.resume(); // Deprecated in Java 1.2
    }
  }
} ///:Continued
```

`SuspendResume1`也提供了一個同步的`run()`方法。同樣地，當我們啟動這個線程以後，就會發現與它關聯的`Peeker`進入“堵塞”狀態，等候物件鎖被釋放，但那永遠不會發生。和往常一樣，這個問題在`SuspendResume2`裡得到了解決，它並不同步整個`run()`方法，而是採用了一個單獨的同步`change()`方法。

對於Java 1.2，大家應注意`suspend()`和`resume()`已獲得強烈反對，因為`suspend()`包含了物件鎖，所以極易出現“死鎖”現象。換言之，很容易就會看到許多被鎖住的物件在傻乎乎地等待對方。這會造成整個應用程序的“凝固”。儘管在一些老程序中還能看到它們的蹤跡，但在你寫自己的程序時，無論如何都應避免。本章稍後就會講述正確的方法是什麼。

(3) 等待和通知

通過前兩個例子的實踐，我們知道無論`sleep()`還是`suspend()`都不會在自己被呼叫的時候解除鎖定。需要用到物件鎖時，請務必注意這個問題。在另一方面，`wait()`方法在被呼叫時卻會解除鎖定，這意味著可在執行`wait()`期間呼叫線程物件中的其他同步方法。但在接著的兩個類中，我們看到`run()`方法都是“同步”的。在`wait()`期間，`Peeker`仍然擁有對同步方法的完全訪問權限。這是由於`wait()`在掛起內部呼叫的方法時，會解除物件的鎖定。

我們也可以看到`wait()`的兩種形式。第一種形式採用一個以毫秒為單位的參數，它具有與`sleep()`中相同的含義：暫停這一段規定時間。區別在於在`wait()`中，物件鎖已被解除，而且能夠自由地退出`wait()`，因為一個`notify()`可強行使時間流逝。

第二種形式不採用任何參數，這意味著`wait()`會持續執行，直到`notify()`介入為止。而且在一段時間以後，不會自行中止。

`wait()`和`notify()`比較特別的一個地方是這兩個方法都屬於基類`Object`的一部分，不像`sleep()`，`suspend()`以及`resume()`那樣屬於`Thread`的一部分。儘管這表面看有點兒奇怪——居然讓專門進行線程處理的東西成為通用基類的一部分——但仔細想想又會釋然，因為它們操縱的物件鎖也屬於每個物件的一部分。因此，我們可將一個`wait()`置入任何同步方法內部，無論在那個類裡是否準備進行涉及線程的處理。事實上，我們能呼叫`wait()`的唯一地方是在一個同步的方法或程式碼塊內部。若在一個不同步的方法內呼叫`wait()`或者`notify()`，儘管程序仍然會編譯，但在運行它的時候，就會得到一個`IllegalMonitorStateException`（非法監視器狀態異常），而且會出現多少有點莫名其妙的一則訊息：`current thread not owner`（當前線程不是所有人”。注意`sleep()`，`suspend()`以及`resume()`都能在不同步的方法內呼叫，因為它們不需要對鎖定進行操作。

只能為自己的鎖定呼叫`wait()`和`notify()`。同樣地，仍然可以編譯那些試圖使用錯誤鎖定的程式碼，但和往常一樣會產生同樣的`IllegalMonitorStateException`異常。我們沒辦法用其他人的物件鎖來愚弄系統，但可要求另一個物件執行相應的操作，對它自己的鎖進行操作。所以一種做法是創建一個同步方法，令其為自己的物件呼叫`notify()`。但在`Notifier`中，我們會看到一個同步方法內部的`notify()`：

```
synchronized(wn2) {
  wn2.notify();
}
```

其中，`wn2`是類型為`WaitNotify2`的物件。儘管並不屬於`WaitNotify2`的一部分，這個方法仍然獲得了`wn2`物件的鎖定。在這個時候，它為`wn2`呼叫`notify()`是合法的，不會得到`IllegalMonitorStateException`異常。

```
///:Continuing
/////////// Blocking via wait() ///////////
class WaitNotify1 extends Blockable {
  public WaitNotify1(Container c) { super(c); }
  public synchronized void run() {
    while(true) {
      i++;
      update();
       try {
        wait(1000);
      } catch (InterruptedException e){}
    }
  }
}

class WaitNotify2 extends Blockable {
  public WaitNotify2(Container c) {
    super(c);
    new Notifier(this);
  }
  public synchronized void run() {
    while(true) {
      i++;
      update();
       try {
        wait();
      } catch (InterruptedException e){}
    }
  }
}

class Notifier extends Thread {
  private WaitNotify2 wn2;
  public Notifier(WaitNotify2 wn2) {
    this.wn2 = wn2;
    start();
  }
  public void run() {
    while(true) {
       try {
        sleep(2000);
      } catch (InterruptedException e){}
      synchronized(wn2) {
        wn2.notify();
      }
    }
  }
} ///:Continued
```

若必須等候其他某些條件（從線程外部加以控制）發生變化，同時又不想在線程內一直傻乎乎地等下去，一般就需要用到`wait()`。`wait()`允許我們將線程置入“睡眠”狀態，同時又“積極”地等待條件發生改變。而且只有在一個`notify()`或`notifyAll()`發生變化的時候，線程才會被喚醒，並檢查條件是否有變。因此，我們認為它提供了在線程間進行同步的一種手段。

(4) IO堵塞

若一個數據流必須等候一些IO活動，便會自動進入“堵塞”狀態。在本例下面列出的部分中，有兩個類協同通用的`Reader`以及`Writer`物件工作（使用Java 1.1的流）。但在測試模型中，會設置一個管道化的數據流，使兩個線程相互間能安全地傳遞數據（這正是使用管道流的目的）。

`Sender`將數據置入`Writer`，並“睡眠”隨機長短的時間。然而，`Receiver`本身並沒有包括`sleep()`，`suspend()`或者`wait()`方法。但在執行`read()`的時候，如果沒有數據存在，它會自動進入“堵塞”狀態。如下所示：

```
///:Continuing
class Sender extends Blockable { // send
  private Writer out;
  public Sender(Container c, Writer out) {
    super(c);
    this.out = out;
  }
  public void run() {
    while(true) {
      for(char c = 'A'; c <= 'z'; c++) {
         try {
          i++;
          out.write(c);
          state.setText("Sender sent: "
            + (char)c);
          sleep((int)(3000 * Math.random()));
        } catch (InterruptedException e){}
          catch (IOException e) {}
      }
    }
  }
}

class Receiver extends Blockable {
  private Reader in;
  public Receiver(Container c, Reader in) {
    super(c);
    this.in = in;
  }
  public void run() {
    try {
      while(true) {
        i++; // Show peeker it's alive
        // Blocks until characters are there:
        state.setText("Receiver read: "
          + (char)in.read());
      }
    } catch(IOException e) { e.printStackTrace();}
  }
} ///:Continued
```

這兩個類也將信息送入自己的`state`字段，並修改`i`值，使`Peeker`知道線程仍在運行。

(5) 測試

令人驚訝的是，主要的程序片（Applet）類非常簡單，這是大多數工作都已置入`Blockable`框架的緣故。大概地說，我們創建了一個由`Blockable`物件構成的數組。而且由於每個物件都是一個線程，所以在按下`"start"`按鈕後，它們會採取自己的行動。還有另一個按鈕和`actionPerformed()`從句，用於中止所有`Peeker`物件。由於Java 1.2“反對”使用`Thread`的`stop()`方法，所以可考慮採用這種折衷形式的中止方式。

為了在`Sender`和`Receiver`之間建立一個連接，我們創建了一個`PipedWriter`和一個`PipedReader`。注意`PipedReader in`必須通過一個構造器參數同`PipedWriterout`連接起來。在那以後，我們在`out`內放進去的所有東西都可從`in`中提取出來——似乎那些東西是通過一個“管道”傳輸過去的。隨後將`in`和`out`物件分別傳遞給`Receiver`和`Sender`構造器；後者將它們當作任意類型的`Reader`和`Writer`看待（也就是說，它們被“上溯”轉換了）。

`Blockable`引用`b`的數組在定義之初並未得到初始化，因為管道化的數據流是不可在定義前設置好的（對`try`塊的需要將成為障礙）：

```
///:Continuing
/////////// Testing Everything ///////////
public class Blocking extends Applet {
  private Button
    start = new Button("Start"),
    stopPeekers = new Button("Stop Peekers");
  private boolean started = false;
  private Blockable[] b;
  private PipedWriter out;
  private PipedReader in;
  public void init() {
     out = new PipedWriter();
    try {
      in = new PipedReader(out);
    } catch(IOException e) {}
    b = new Blockable[] {
      new Sleeper1(this),
      new Sleeper2(this),
      new SuspendResume1(this),
      new SuspendResume2(this),
      new WaitNotify1(this),
      new WaitNotify2(this),
      new Sender(this, out),
      new Receiver(this, in)
    };
    start.addActionListener(new StartL());
    add(start);
    stopPeekers.addActionListener(
      new StopPeekersL());
    add(stopPeekers);
  }
  class StartL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      if(!started) {
        started = true;
        for(int i = 0; i < b.length; i++)
          b[i].start();
      }
    }
  }
  class StopPeekersL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      // Demonstration of the preferred
      // alternative to Thread.stop():
      for(int i = 0; i < b.length; i++)
        b[i].stopPeeker();
    }
  }
  public static void main(String[] args) {
    Blocking applet = new Blocking();
    Frame aFrame = new Frame("Blocking");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(350,550);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

在`init()`中，注意循環會遍歷整個數組，併為頁添加`state`和`peeker.status`文本字段。

首次創建好`Blockable`線程以後，每個這樣的線程都會自動創建並啟動自己的`Peeker`。所以我們會看到各個`Peeker`都在`Blockable`線程啟動之前運行起來。這一點非常重要，因為在`Blockable`線程啟動的時候，部分`Peeker`會被堵塞，並停止運行。弄懂這一點，將有助於我們加深對“堵塞”這一概念的認識。

## 14.3.2 死鎖

由於線程可能進入堵塞狀態，而且由於物件可能擁有“同步”方法——除非同步鎖定被解除，否則線程不能訪問那個物件——所以一個線程完全可能等候另一個物件，而另一個物件又在等候下一個物件，以此類推。這個“等候”鏈最可怕的情形就是進入封閉狀態——最後那個物件等候的是第一個物件！此時，所有線程都會陷入無休止的相互等待狀態，大家都動彈不得。我們將這種情況稱為“死鎖”。儘管這種情況並非經常出現，但一旦碰到，程序的調試將變得異常艱難。

就語言本身來說，尚未直接提供防止死鎖的幫助措施，需要我們通過謹慎的設計來避免。如果有誰需要調試一個死鎖的程序，他是沒有任何竅門可用的。

(1) Java 1.2對`stop()`，`suspend()`，`resume()`以及`destroy()`的反對

為減少出現死鎖的可能，Java 1.2作出的一項貢獻是“反對”使用`Thread`的`stop()`，`suspend()`，`resume()`以及`destroy()`方法。

之所以反對使用`stop()`，是因為它不安全。它會解除由線程獲取的所有鎖定，而且如果物件處於一種不連貫狀態（“被析構”），那麼其他線程能在那種狀態下檢查和修改它們。結果便造成了一種微妙的局面，我們很難檢查出真正的問題所在。所以應儘量避免使用`stop()`，應該採用`Blocking.java`那樣的方法，用一個標誌告訴線程什麼時候通過退出自己的`run()`方法來中止自己的執行。

如果一個線程被堵塞，比如在它等候輸入的時候，那麼一般都不能象在`Blocking.java`中那樣輪詢一個標誌。但在這些情況下，我們仍然不該使用`stop()`，而應換用由`Thread`提供的`interrupt()`方法，以便中止並退出堵塞的程式碼。

```
//: Interrupt.java
// The alternative approach to using stop()
// when a thread is blocked
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

class Blocked extends Thread {
  public synchronized void run() {
    try {
      wait(); // Blocks
    } catch(InterruptedException e) {
      System.out.println("InterruptedException");
    }
    System.out.println("Exiting run()");
  }
}

public class Interrupt extends Applet {
  private Button
    interrupt = new Button("Interrupt");
  private Blocked blocked = new Blocked();
  public void init() {
    add(interrupt);
    interrupt.addActionListener(
      new ActionListener() {
        public
        void actionPerformed(ActionEvent e) {
          System.out.println("Button pressed");
          if(blocked == null) return;
          Thread remove = blocked;
          blocked = null; // to release it
          remove.interrupt();
        }
      });
    blocked.start();
  }
  public static void main(String[] args) {
    Interrupt applet = new Interrupt();
    Frame aFrame = new Frame("Interrupt");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(200,100);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

`Blocked.run()`內部的`wait()`會產生堵塞的線程。當我們按下按鈕以後，`blocked`（堵塞）的引用就會設為`null`，使垃圾收集器能夠將其清除，然後呼叫物件的`interrupt()`方法。如果是首次按下按鈕，我們會看到線程正常退出。但在沒有可供“殺死”的線程以後，看到的便只是按鈕被按下而已。

`suspend()`和`resume()`方法天生容易發生死鎖。呼叫`suspend()`的時候，目標線程會停下來，但卻仍然持有在這之前獲得的鎖定。此時，其他任何線程都不能訪問鎖定的資源，除非被“掛起”的線程恢復運行。對任何線程來說，如果它們想恢復目標線程，同時又試圖使用任何一個鎖定的資源，就會造成令人難堪的死鎖。所以我們不應該使用`suspend()`和`resume()`，而應在自己的`Thread`類中置入一個標誌，指出線程應該活動還是掛起。若標誌指出線程應該掛起，便用`wait()`命其進入等待狀態。若標誌指出線程應當恢復，則用一個`notify()`重新啟動線程。我們可以修改前面的`Counter2.java`來實際體驗一番。儘管兩個版本的效果是差不多的，但大家會注意到程式碼的組織結構發生了很大的變化——為所有“聽眾”都使用了匿名的內部類，而且`Thread`是一個內部類。這使得程序的編寫稍微方便一些，因為它取消了`Counter2.java`中一些額外的記錄工作。

```
//: Suspend.java
// The alternative approach to using suspend()
// and resume(), which have been deprecated
// in Java 1.2.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

public class Suspend extends Applet {
  private TextField t = new TextField(10);
  private Button
    suspend = new Button("Suspend"),
    resume = new Button("Resume");
  class Suspendable extends Thread {
    private int count = 0;
    private boolean suspended = false;
    public Suspendable() { start(); }
    public void fauxSuspend() {
      suspended = true;
    }
    public synchronized void fauxResume() {
      suspended = false;
      notify();
    }
    public void run() {
      while (true) {
        try {
          sleep(100);
          synchronized(this) {
            while(suspended)
              wait();
          }
        } catch (InterruptedException e){}
        t.setText(Integer.toString(count++));
      }
    }
  }
  private Suspendable ss = new Suspendable();
  public void init() {
    add(t);
    suspend.addActionListener(
      new ActionListener() {
        public
        void actionPerformed(ActionEvent e) {
          ss.fauxSuspend();
        }
      });
    add(suspend);
    resume.addActionListener(
      new ActionListener() {
        public
        void actionPerformed(ActionEvent e) {
          ss.fauxResume();
        }
      });
    add(resume);
  }
  public static void main(String[] args) {
    Suspend applet = new Suspend();
    Frame aFrame = new Frame("Suspend");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e){
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(300,100);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

`Suspendable`中的`suspended`（已掛起）標誌用於開關“掛起”或者“暫停”狀態。為掛起一個線程，只需呼叫`fauxSuspend(`)將標誌設為`true`（真）即可。對標誌狀態的偵測是在`run()`內進行的。就象本章早些時候提到的那樣，`wait()`必須設為“同步”（`synchronized`），使其能夠使用物件鎖。在`fauxResume()`中，`suspended`標誌被設為`false`（假），並呼叫`notify()`——由於這會在一個“同步”從句中喚醒`wait()`，所以`fauxResume()`方法也必須同步，使其能在呼叫`notify()`之前取得物件鎖（這樣一來，物件鎖可由要喚醍的那個`wait()`使用）。如果遵照本程序展示的樣式，可以避免使用`wait()`和`notify()`。

`Thread`的`destroy()`方法根本沒有實作；它類似一個根本不能恢復的`suspend()`，所以會發生與`suspend()`一樣的死鎖問題。然而，這一方法沒有得到明確的“反對”，也許會在Java以後的版本（1.2版以後）實作，用於一些可以承受死鎖危險的特殊場合。

大家可能會奇怪當初為什麼要實作這些現在又被“反對”的方法。之所以會出現這種情況，大概是由於Sun公司主要讓技術人員來決定對語言的改動，而不是那些市場銷售人員。通常，技術人員比搞銷售的更能理解語言的實質。當初犯下了錯誤以後，也能較為理智地正視它們。這意味著Java能夠繼續進步，即便這使Java程序員多少感到有些不便。就我自己來說，寧願面對這些不便之處，也不願看到語言停滯不前。


# 14.4 優先級


線程的優先級（Priority）告訴調試程序該線程的重要程度有多大。如果有大量線程都被堵塞，都在等候運行，調試程序會首先運行具有最高優先級的那個線程。然而，這並不表示優先級較低的線程不會運行（換言之，不會因為存在優先級而導致死鎖）。若線程的優先級較低，只不過表示它被準許運行的機會小一些而已。

可用`getPriority()`方法讀取一個線程的優先級，並用`setPriority()`改變它。在下面這個程序片中，大家會發現計數器的計數速度慢了下來，因為它們關聯的線程分配了較低的優先級：

```
//: Counter5.java
// Adjusting the priorities of threads
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

class Ticker2 extends Thread {
  private Button
    b = new Button("Toggle"),
    incPriority = new Button("up"),
    decPriority = new Button("down");
  private TextField
    t = new TextField(10),
    pr = new TextField(3); // Display priority
  private int count = 0;
  private boolean runFlag = true;
  public Ticker2(Container c) {
    b.addActionListener(new ToggleL());
    incPriority.addActionListener(new UpL());
    decPriority.addActionListener(new DownL());
    Panel p = new Panel();
    p.add(t);
    p.add(pr);
    p.add(b);
    p.add(incPriority);
    p.add(decPriority);
    c.add(p);
  }
  class ToggleL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      runFlag = !runFlag;
    }
  }
  class UpL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      int newPriority = getPriority() + 1;
      if(newPriority > Thread.MAX_PRIORITY)
        newPriority = Thread.MAX_PRIORITY;
      setPriority(newPriority);
    }
  }
  class DownL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      int newPriority = getPriority() - 1;
      if(newPriority < Thread.MIN_PRIORITY)
        newPriority = Thread.MIN_PRIORITY;
      setPriority(newPriority);
    }
  }
  public void run() {
    while (true) {
      if(runFlag) {
        t.setText(Integer.toString(count++));
        pr.setText(
          Integer.toString(getPriority()));
      }
      yield();
    }
  }
}

public class Counter5 extends Applet {
  private Button
    start = new Button("Start"),
    upMax = new Button("Inc Max Priority"),
    downMax = new Button("Dec Max Priority");
  private boolean started = false;
  private static final int SIZE = 10;
  private Ticker2[] s = new Ticker2[SIZE];
  private TextField mp = new TextField(3);
  public void init() {
    for(int i = 0; i < s.length; i++)
      s[i] = new Ticker2(this);
    add(new Label("MAX_PRIORITY = "
      + Thread.MAX_PRIORITY));
    add(new Label("MIN_PRIORITY = "
      + Thread.MIN_PRIORITY));
    add(new Label("Group Max Priority = "));
    add(mp);
    add(start);
    add(upMax); add(downMax);
    start.addActionListener(new StartL());
    upMax.addActionListener(new UpMaxL());
    downMax.addActionListener(new DownMaxL());
    showMaxPriority();
    // Recursively display parent thread groups:
    ThreadGroup parent =
      s[0].getThreadGroup().getParent();
    while(parent != null) {
      add(new Label(
        "Parent threadgroup max priority = "
        + parent.getMaxPriority()));
      parent = parent.getParent();
    }
  }
  public void showMaxPriority() {
    mp.setText(Integer.toString(
      s[0].getThreadGroup().getMaxPriority()));
  }
  class StartL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      if(!started) {
        started = true;
        for(int i = 0; i < s.length; i++)
          s[i].start();
      }
    }
  }
  class UpMaxL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      int maxp =
        s[0].getThreadGroup().getMaxPriority();
      if(++maxp > Thread.MAX_PRIORITY)
        maxp = Thread.MAX_PRIORITY;
      s[0].getThreadGroup().setMaxPriority(maxp);
      showMaxPriority();
    }
  }
  class DownMaxL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      int maxp =
        s[0].getThreadGroup().getMaxPriority();
      if(--maxp < Thread.MIN_PRIORITY)
        maxp = Thread.MIN_PRIORITY;
      s[0].getThreadGroup().setMaxPriority(maxp);
      showMaxPriority();
    }
  }
  public static void main(String[] args) {
    Counter5 applet = new Counter5();
    Frame aFrame = new Frame("Counter5");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(300, 600);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

`Ticker`採用本章前面構造好的形式，但有一個額外的`TextField`（文本字段），用於顯示線程的優先級；以及兩個額外的按鈕，用於人為提高及降低優先級。

也要注意`yield()`的用法，它將控制權自動返回給調試程序（機制）。若不進行這樣的處理，多線程機制仍會工作，但我們會發現它的運行速度慢了下來（試試刪去對`yield()`的呼叫）。亦可呼叫`sleep()`，但假若那樣做，計數頻率就會改由`sleep()`的持續時間控制，而不是優先級。

`Counter5`中的`init()`創建了由10個`Ticker2`構成的一個數組；它們的按鈕以及輸入字段（文本字段）由`Ticker2`構造器置入窗體。`Counter5`增加了新的按鈕，用於啟動一切，以及用於提高和降低線程組的最大優先級。除此以外，還有一些標籤用於顯示一個線程可以採用的最大及最小優先級；以及一個特殊的文本字段，用於顯示線程組的最大優先級（在下一節裡，我們將全面討論線程組的問題）。最後，父線程組的優先級也作為標籤顯示出來。

按下`up`（上）或`down`（下）按鈕的時候，會先取得`Ticker2`當前的優先級，然後相應地提高或者降低。

運行該程序時，我們可注意到幾件事情。首先，線程組的默認優先級是5。即使在啟動線程之前（或者在創建線程之前，這要求對程式碼進行適當的修改）將最大優先級降到5以下，每個線程都會有一個5的默認優先級。

最簡單的測試是獲取一個計數器，將它的優先級降低至1，此時應觀察到它的計數頻率顯著放慢。現在試著再次提高優先級，可以升高回線程組的優先級，但不能再高了。現在將線程組的優先級降低兩次。線程的優先級不會改變，但假若試圖提高或者降低它，就會發現這個優先級自動變成線程組的優先級。此外，新線程仍然具有一個默認優先級，即使它比組的優先級還要高（換句話說，不要指望利用組優先級來防止新線程擁有比現有的更高的優先級）。

最後，試著提高組的最大優先級。可以發現，這樣做是沒有效果的。我們只能減少線程組的最大優先級，而不能增大它。

## 14.4.1 線程組

所有線程都隸屬於一個線程組。那可以是一個默認線程組，亦可是一個創建線程時明確指定的組。在創建之初，線程被限制到一個組裡，而且不能改變到一個不同的組。每個應用都至少有一個線程從屬於系統線程組。若創建多個線程而不指定一個組，它們就會自動歸屬於系統線程組。

線程組也必須從屬於其他線程組。必須在構造器裡指定新線程組從屬於哪個線程組。若在創建一個線程組的時候沒有指定它的歸屬，則同樣會自動成為系統線程組的一名屬下。因此，一個應用程序中的所有線程組最終都會將系統線程組作為自己的“父”。

之所以要提出“線程組”的概念，很難從字面上找到原因。這多少為我們討論的主題帶來了一些混亂。一般地說，我們認為是由於“安全”或者“保密”方面的理由才使用線程組的。根據Arnold和Gosling的說法：“線程組中的線程可以修改組內的其他線程，包括那些位於分層結構最深處的。一個線程不能修改位於自己所在組或者下屬組之外的任何線程”（註釋①）。然而，我們很難判斷“修改”在這兒的具體含義是什麼。下面這個例子展示了位於一個“葉子組”內的線程能修改它所在線程組樹的所有線程的優先級，同時還能為這個“樹”內的所有線程都呼叫一個方法。

```
①：《The Java Programming Language》第179頁。該書由Arnold和Jams Gosling編著，Addison-Wesley於1996年出版
//: TestAccess.java
// How threads can access other threads
// in a parent thread group

public class TestAccess {
  public static void main(String[] args) {
    ThreadGroup
      x = new ThreadGroup("x"),
      y = new ThreadGroup(x, "y"),
      z = new ThreadGroup(y, "z");
    Thread
      one = new TestThread1(x, "one"),
      two = new TestThread2(z, "two");
  }
}

class TestThread1 extends Thread {
  private int i;
  TestThread1(ThreadGroup g, String name) {
    super(g, name);
  }
  void f() {
    i++; // modify this thread
    System.out.println(getName() + " f()");
  }
}

class TestThread2 extends TestThread1 {
  TestThread2(ThreadGroup g, String name) {
    super(g, name);
    start();
  }
  public void run() {
    ThreadGroup g =
      getThreadGroup().getParent().getParent();
    g.list();
    Thread[] gAll = new Thread[g.activeCount()];
    g.enumerate(gAll);
    for(int i = 0; i < gAll.length; i++) {
      gAll[i].setPriority(Thread.MIN_PRIORITY);
      ((TestThread1)gAll[i]).f();
    }
    g.list();
  }
} ///:~

```

在`main()`中，我們創建了幾個`ThreadGroup`（線程組），每個都位於不同的“葉”上：`x`沒有參數，只有它的名字（一個`String`），所以會自動進入`system`（系統）線程組；`y`位於`x`下方，而`z`位於`y`下方。注意初始化是按照文字順序進行的，所以程式碼合法。

有兩個線程創建之後進入了不同的線程組。其中，`TestThread1`沒有一個`run()`方法，但有一個`f()`，用於通知線程以及打印出一些東西，以便我們知道它已被呼叫。而`TestThread2`屬於`TestThread1`的一個子類，它的`run()`非常詳盡，要做許多事情。首先，它獲得當前線程所在的線程組，然後利用`getParent()`在繼承樹中向上移動兩級（這樣做是有道理的，因為我想把`TestThread2`在分級結構中向下移動兩級）。隨後，我們呼叫方法`activeCount()`，查詢這個線程組以及所有子線程組內有多少個線程，從而創建由指向`Thread`的引用構成的一個數組。`enumerate()`方法將指向所有這些線程的引用置入數組`gAll`裡。然後在整個數組裡遍歷，為每個線程都呼叫`f()`方法，同時修改優先級。這樣一來，位於一個“葉子”線程組裡的線程就修改了位於父線程組的線程。

調試方法`list()`打印出與一個線程組有關的所有信息，把它們作為標準輸出。在我們對線程組的行為進行調查的時候，這樣做是相當有好處的。下面是程序的輸出：

```
java.lang.ThreadGroup[name=x,maxpri=10]
    Thread[one,5,x]
    java.lang.ThreadGroup[name=y,maxpri=10]
        java.lang.ThreadGroup[name=z,maxpri=10]
            Thread[two,5,z]
one f()
two f()
java.lang.ThreadGroup[name=x,maxpri=10]
    Thread[one,1,x]
    java.lang.ThreadGroup[name=y,maxpri=10]
        java.lang.ThreadGroup[name=z,maxpri=10]
            Thread[two,1,z]
```

`list()`不僅打印出`ThreadGroup`或者`Thread`的類名，也打印出了線程組的名字以及它的最高優先級。對於線程，則打印出它們的名字，並接上線程優先級以及所屬的線程組。注意`list()`會對線程和線程組進行縮排處理，指出它們是未縮排的線程組的“子”。

大家可看到`f()`是由`TestThread2`的`run()`方法呼叫的，所以很明顯，組內的所有線程都是相當脆弱的。然而，我們只能訪問那些從自己的`system`線程組樹分支出來的線程，而且或許這就是所謂“安全”的意思。我們不能訪問其他任何人的系統線程樹。

(1) 線程組的控制

拋開安全問題不談，線程組最有用的一個地方就是控制：只需用單個命令即可完成對整個線程組的操作。下面這個例子演示了這一點，並對線程組內優先級的限制進行了說明。括號內的註釋數字便於大家比較輸出結果：

```
//: ThreadGroup1.java
// How thread groups control priorities
// of the threads inside them.

public class ThreadGroup1 {
  public static void main(String[] args) {
    // Get the system thread & print its Info:
    ThreadGroup sys =
      Thread.currentThread().getThreadGroup();
    sys.list(); // (1)
    // Reduce the system thread group priority:
    sys.setMaxPriority(Thread.MAX_PRIORITY - 1);
    // Increase the main thread priority:
    Thread curr = Thread.currentThread();
    curr.setPriority(curr.getPriority() + 1);
    sys.list(); // (2)
    // Attempt to set a new group to the max:
    ThreadGroup g1 = new ThreadGroup("g1");
    g1.setMaxPriority(Thread.MAX_PRIORITY);
    // Attempt to set a new thread to the max:
    Thread t = new Thread(g1, "A");
    t.setPriority(Thread.MAX_PRIORITY);
    g1.list(); // (3)
    // Reduce g1's max priority, then attempt
    // to increase it:
    g1.setMaxPriority(Thread.MAX_PRIORITY - 2);
    g1.setMaxPriority(Thread.MAX_PRIORITY);
    g1.list(); // (4)
    // Attempt to set a new thread to the max:
    t = new Thread(g1, "B");
    t.setPriority(Thread.MAX_PRIORITY);
    g1.list(); // (5)
    // Lower the max priority below the default
    // thread priority:
    g1.setMaxPriority(Thread.MIN_PRIORITY + 2);
    // Look at a new thread's priority before
    // and after changing it:
    t = new Thread(g1, "C");
    g1.list(); // (6)
    t.setPriority(t.getPriority() -1);
    g1.list(); // (7)
    // Make g2 a child Threadgroup of g1 and
    // try to increase its priority:
    ThreadGroup g2 = new ThreadGroup(g1, "g2");
    g2.list(); // (8)
    g2.setMaxPriority(Thread.MAX_PRIORITY);
    g2.list(); // (9)
    // Add a bunch of new threads to g2:
    for (int i = 0; i < 5; i++)
      new Thread(g2, Integer.toString(i));
    // Show information about all threadgroups
    // and threads:
    sys.list(); // (10)
    System.out.println("Starting all threads:");
    Thread[] all = new Thread[sys.activeCount()];
    sys.enumerate(all);
    for(int i = 0; i < all.length; i++)
      if(!all[i].isAlive())
        all[i].start();
    // Suspends & Stops all threads in
    // this group and its subgroups:
    System.out.println("All threads started");
    sys.suspend(); // Deprecated in Java 1.2
    // Never gets here...
    System.out.println("All threads suspended");
    sys.stop(); // Deprecated in Java 1.2
    System.out.println("All threads stopped");
  }
} ///:~
```

下面的輸出結果已進行了適當的編輯，以便用一頁能夠裝下（`java.lang.`已被刪去），而且添加了適當的數字，與前面程序列表中括號裡的數字對應：

```
(1) ThreadGroup[name=system,maxpri=10]
      Thread[main,5,system]
(2) ThreadGroup[name=system,maxpri=9]
      Thread[main,6,system]
(3) ThreadGroup[name=g1,maxpri=9]
      Thread[A,9,g1]
(4) ThreadGroup[name=g1,maxpri=8]
      Thread[A,9,g1]
(5) ThreadGroup[name=g1,maxpri=8]
      Thread[A,9,g1]
      Thread[B,8,g1]
(6) ThreadGroup[name=g1,maxpri=3]
      Thread[A,9,g1]
      Thread[B,8,g1]
      Thread[C,6,g1]
(7) ThreadGroup[name=g1,maxpri=3]
      Thread[A,9,g1]
      Thread[B,8,g1]
      Thread[C,3,g1]
(8) ThreadGroup[name=g2,maxpri=3]
(9) ThreadGroup[name=g2,maxpri=3]
(10)ThreadGroup[name=system,maxpri=9]
      Thread[main,6,system]
      ThreadGroup[name=g1,maxpri=3]
        Thread[A,9,g1]
        Thread[B,8,g1]
        Thread[C,3,g1]
        ThreadGroup[name=g2,maxpri=3]
          Thread[0,6,g2]
          Thread[1,6,g2]
          Thread[2,6,g2]
          Thread[3,6,g2]
          Thread[4,6,g2]
Starting all threads:
All threads started
```

所有程序都至少有一個線程在運行，而且`main()`採取的第一項行動便是呼叫`Thread`的一個`static`（靜態）方法，名為`currentThread()`。從這個線程開始，線程組將被創建，而且會為結果呼叫`list()`。輸出如下：

```
(1) ThreadGroup[name=system,maxpri=10]
      Thread[main,5,system]
```

我們可以看到，主線程組的名字是`system`，而主線程的名字是`main`，而且它從屬於`system`線程組。

第二個練習顯示出`system`組的最高優先級可以減少，而且`main`線程可以增大自己的優先級：

```
(2) ThreadGroup[name=system,maxpri=9]
      Thread[main,6,system]
```

第三個練習創建一個新的線程組，名為`g1`；它自動從屬於`system`線程組，因為並沒有明確指定它的歸屬關係。我們在`g1`內部放置了一個新線程，名為`A`。隨後，我們試著將這個組的最大優先級設到最高的級別，並將`A`的優先級也設到最高一級。結果如下：

```
(3) ThreadGroup[name=g1,maxpri=9]
      Thread[A,9,g1]
```      

可以看出，不可能將線程組的最大優先級設為高於它的父線程組。

第四個練習將`g1`的最大優先級降低兩級，然後試著把它升至`Thread.MAX_PRIORITY`。結果如下：

```
(4) ThreadGroup[name=g1,maxpri=8]
      Thread[A,9,g1]
```

同樣可以看出，提高最大優先級的企圖是失敗的。我們只能降低一個線程組的最大優先級，而不能提高它。此外，注意線程A的優先級並未改變，而且它現在高於線程組的最大優先級。也就是說，線程組最大優先級的變化並不能對現有線程造成影響。

第五個練習試著將一個新線程設為最大優先級。如下所示：

```
(5) ThreadGroup[name=g1,maxpri=8]
      Thread[A,9,g1]
      Thread[B,8,g1]
```

因此，新線程不能變到比最大線程組優先級還要高的一級。

這個程序的默認線程優先級是6；若新建一個線程，那就是它的默認優先級，而且不會發生變化，除非對優先級進行了特別的處理。練習六將把線程組的最大優先級降至默認線程優先級以下，看看在這種情況下新建一個線程會發生什麼事情：

```
(6) ThreadGroup[name=g1,maxpri=3]
      Thread[A,9,g1]
      Thread[B,8,g1]
      Thread[C,6,g1]
```

儘管線程組現在的最大優先級是3，但仍然用默認優先級6來創建新線程。所以，線程組的最大優先級不會影響默認優先級（事實上，似乎沒有辦法可以設置新線程的默認優先級）。

改變了優先級後，接下來試試將其降低一級，結果如下：

```
(7) ThreadGroup[name=g1,maxpri=3]
      Thread[A,9,g1]
      Thread[B,8,g1]
      Thread[C,3,g1]
```

因此，只有在試圖改變優先級的時候，才會強迫遵守線程組最大優先級的限制。

我們在(8)和(9)中進行了類似的試驗。在這裡，我們創建了一個新的線程組，名為`g2`，將其作為`g1`的一個子組，並改變了它的最大優先級。大家可以看到，`g2`的優先級無論如何都不可能高於`g1`：

```
(8) ThreadGroup[name=g2,maxpri=3]
(9) ThreadGroup[name=g2,maxpri=3]
```

也要注意在`g2`創建的時候，它會被自動設為`g1`的線程組最大優先級。

經過所有這些實驗以後，整個線程組和線程系統都會被打印出來，如下所示：

```
(10)ThreadGroup[name=system,maxpri=9]
      Thread[main,6,system]
      ThreadGroup[name=g1,maxpri=3]
        Thread[A,9,g1]
        Thread[B,8,g1]
        Thread[C,3,g1]
        ThreadGroup[name=g2,maxpri=3]
          Thread[0,6,g2]
          Thread[1,6,g2]
          Thread[2,6,g2]
          Thread[3,6,g2]
          Thread[4,6,g2]
```

所以由線程組的規則所限，一個子組的最大優先級在任何時候都只能低於或等於它的父組的最大優先級。

本程序的最後一個部分演示了用於整組線程的方法。程序首先遍歷整個線程樹，並啟動每一個尚未啟動的線程。例如，`system`組隨後會被掛起（暫停），最後被中止（儘管用`suspend()`和`stop()`對整個線程組進行操作看起來似乎很有趣，但應注意這些方法在Java 1.2裡都是被“反對”的）。但在掛起`system`組的同時，也掛起了`main`線程，而且整個程序都會關閉。所以永遠不會達到讓線程中止的那一步。實際上，假如真的中止了`main`線程，它會“拋”出一個`ThreadDeath`異常，所以我們通常不這樣做。由於`ThreadGroup`是從`Object`繼承的，其中包含了`wait()`方法，所以也能呼叫`wait(秒數×1000)`，令程序暫停運行任意秒數的時間。當然，事前必須在一個同步塊裡取得物件鎖。

`ThreadGroup`類也提供了`suspend()`和`resume()`方法，所以能中止和啟動整個線程組和它的所有線程，也能中止和啟動它的子組，所有這些只需一個命令即可（再次提醒，`suspend()`和`resume()`都是Java 1.2所“反對”的）。

從表面看，線程組似乎有些讓人摸不著頭腦，但請注意我們很少需要直接使用它們。


# 14.5 回顧runnable


在本章早些時候，我曾建議大家在將一個程序片或主`Frame`當作`Runnable`的實作形式之前，一定要好好地想一想。若採用那種方式，就只能在自己的程序中使用其中的一個線程。這便限制了靈活性，一旦需要用到屬於那種類型的多個線程，就會遇到不必要的麻煩。

當然，如果必須從一個類繼承，而且想使類具有線程處理能力，則`Runnable`是一種正確的方法。本章最後一個例子對這一點進行了剖析，製作了一個`RunnableCanvas`類，用於為自己描繪不同的顏色（`Canvas`是“畫布”的意思）。這個應用被設計成從命令行獲得參數值，以決定顏色網格有多大，以及顏色發生變化之間的`sleep()`有多長。通過運用這些值，大家能體驗到線程一些有趣而且可能令人費解的特性：

```
//: ColorBoxes.java
// Using the Runnable interface
import java.awt.*;
import java.awt.event.*;

class CBox extends Canvas implements Runnable {
  private Thread t;
  private int pause;
  private static final Color[] colors = {
    Color.black, Color.blue, Color.cyan,
    Color.darkGray, Color.gray, Color.green,
    Color.lightGray, Color.magenta,
    Color.orange, Color.pink, Color.red,
    Color.white, Color.yellow
  };
  private Color cColor = newColor();
  private static final Color newColor() {
    return colors[
      (int)(Math.random() * colors.length)
    ];
  }
  public void paint(Graphics  g) {
    g.setColor(cColor);
    Dimension s = getSize();
    g.fillRect(0, 0, s.width, s.height);
  }
  public CBox(int pause) {
    this.pause = pause;
    t = new Thread(this);
    t.start();
  }
  public void run() {
    while(true) {
      cColor = newColor();
      repaint();
      try {
        t.sleep(pause);
      } catch(InterruptedException e) {}
    }
  }
}

public class ColorBoxes extends Frame {
  public ColorBoxes(int pause, int grid) {
    setTitle("ColorBoxes");
    setLayout(new GridLayout(grid, grid));
    for (int i = 0; i < grid * grid; i++)
      add(new CBox(pause));
    addWindowListener(new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        System.exit(0);
      }
    });
  }   
  public static void main(String[] args) {
    int pause = 50;
    int grid = 8;
    if(args.length > 0)
      pause = Integer.parseInt(args[0]);
    if(args.length > 1)
      grid = Integer.parseInt(args[1]);
    Frame f = new ColorBoxes(pause, grid);
    f.setSize(500, 400);
    f.setVisible(true);  
  }
} ///:~
```

`ColorBoxes`是一個典型的應用（程序），有一個構造器用於設置GUI。這個構造器採用`int grid`的一個參數，用它設置`GridLayout`（網格佈局），使每一維裡都有一個`grid`單元。隨後，它添加適當數量的`CBox`物件，用它們填充網格，併為每一個都傳遞`pause`值。在`main()`中，我們可看到如何對`pause`和`grid`的默認值進行修改（如果用命令行參數傳遞）。

`CBox`是進行正式工作的地方。它是從`Canvas`繼承的，並實作了`Runnable`接口，使每個`Canvas`也能是一個`Thread`。記住在實作`Runnable`的時候，並沒有實際產生一個`Thread`物件，只是一個擁有`run()`方法的類。因此，我們必須明確地創建一個`Thread`物件，並將`Runnable`物件傳遞給構造器，隨後呼叫`start()`（在構造器裡進行）。在`CBox`裡，這個線程的名字叫作`t`。

請留意數組`colors`，它對`Color`類中的所有顏色進行了列舉（枚舉）。它在`newColor()`中用於產生一種隨機選擇的顏色。當前的單元（格）顏色是`cColor`。

`paint()`則相當簡單——只是將顏色設為`cColor`，然後用那種顏色填充整張畫布（`Canvas`）。

在`run()`中，我們看到一個無限循環，它將`cColor`設為一種隨機顏色，然後呼叫`repaint()`把它顯示出來。隨後，對線程執行`sleep()`，使其“休眠”由命令行指定的時間長度。

由於這種設計模式非常靈活，而且線程處理同每個`Canvas`元素都緊密結合在一起，所以在理論上可以生成任意多的線程（但在實際應用中，這要受到JVM能夠從容對付的線程數量的限制）。

這個程序也為我們提供了一個有趣的評測基準，因為它揭示了不同JVM機制在速度上造成的戲劇性的差異。

## 14.5.1 過多的線程

有些時候，我們會發現`ColorBoxes`幾乎陷於停頓狀態。在我自己的機器上，這一情況在產生了`10×10`的網格之後發生了。為什麼會這樣呢？自然地，我們有理由懷疑AWT對它做了什麼事情。所以這裡有一個例子能夠測試那個猜測，它產生了較少的線程。程式碼經過了重新組織，使一個`Vector`實作了`Runnable`，而且那個`Vector`容納了數量眾多的色塊，並隨機挑選一些進行更新。隨後，我們創建大量這些`Vector`物件，數量大致取決於我們挑選的網格維數。結果便是我們得到比色塊少得多的線程。所以假如有一個速度的加快，我們就能立即知道，因為前例的線程數量太多了。如下所示：

```
//: ColorBoxes2.java
// Balancing thread use
import java.awt.*;
import java.awt.event.*;
import java.util.*;

class CBox2 extends Canvas {
  private static final Color[] colors = {
    Color.black, Color.blue, Color.cyan,
    Color.darkGray, Color.gray, Color.green,
    Color.lightGray, Color.magenta,
    Color.orange, Color.pink, Color.red,
    Color.white, Color.yellow
  };
  private Color cColor = newColor();
  private static final Color newColor() {
    return colors[
      (int)(Math.random() * colors.length)
    ];
  }
  void nextColor() {
    cColor = newColor();
    repaint();
  }
  public void paint(Graphics  g) {
    g.setColor(cColor);
    Dimension s = getSize();
    g.fillRect(0, 0, s.width, s.height);
  }
}

class CBoxVector
  extends Vector implements Runnable {
  private Thread t;
  private int pause;
  public CBoxVector(int pause) {
    this.pause = pause;
    t = new Thread(this);
  }
  public void go() { t.start(); }
  public void run() {
    while(true) {
      int i = (int)(Math.random() * size());
      ((CBox2)elementAt(i)).nextColor();
      try {
        t.sleep(pause);
      } catch(InterruptedException e) {}
    }
  }
}

public class ColorBoxes2 extends Frame {
  private CBoxVector[] v;
  public ColorBoxes2(int pause, int grid) {
    setTitle("ColorBoxes2");
    setLayout(new GridLayout(grid, grid));
    v = new CBoxVector[grid];
    for(int i = 0; i < grid; i++)
      v[i] = new CBoxVector(pause);
    for (int i = 0; i < grid * grid; i++) {
      v[i % grid].addElement(new CBox2());
      add((CBox2)v[i % grid].lastElement());
    }
    for(int i = 0; i < grid; i++)
      v[i].go();
    addWindowListener(new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        System.exit(0);
      }
    });
  }   
  public static void main(String[] args) {
    // Shorter default pause than ColorBoxes:
    int pause = 5;
    int grid = 8;
    if(args.length > 0)
      pause = Integer.parseInt(args[0]);
    if(args.length > 1)
      grid = Integer.parseInt(args[1]);
    Frame f = new ColorBoxes2(pause, grid);
    f.setSize(500, 400);
    f.setVisible(true);  
  }
} ///:~
```

在`ColorBoxes2`中，我們創建了`CBoxVector`的一個數組，並對其初始化，使其容下各個`CBoxVector`網格。每個網格都知道自己該“睡眠”多長的時間。隨後為每個`CBoxVector`都添加等量的`Cbox2`物件，而且將每個`Vector`都告訴給`go()`，用它來啟動自己的線程。

`CBox2`類似`CBox`——能用一種隨機選擇的顏色描繪自己。但那就是`CBox2`能夠做的全部工作。所有涉及線程的處理都已移至`CBoxVector`進行。

`CBoxVector`也可以擁有繼承的`Thread`，並有一個類型為`Vector`的成員物件。這樣設計的好處就是`addElement()`和`elementAt()`方法可以獲得特定的參數以及返回值類型，而不是隻能獲得常規Object（它們的名字也可以變得更短）。然而，這裡採用的設計表面上看需要較少的程式碼。除此以外，它會自動保留一個`Vector`的其他所有行為。由於`elementAt()`需要大量進行“封閉”工作，用到許多括號，所以隨著程式碼主體的擴充，最終仍有可能需要大量程式碼。

和以前一樣，在我們實作`Runnable`的時候，並沒有獲得與`Thread`配套提供的所有功能，所以必須創建一個新的`Thread`，並將自己傳遞給它的構造器，以便正式“啟動”——`start()`——一些東西。大家在`CBoxVector`構造器和`go()`裡都可以體會到這一點。`run()`方法簡單地選擇`Vector`裡的一個隨機元素編號，併為那個元素呼叫`nextColor()`，令其挑選一種新的隨機顏色。

運行這個程序時，大家會發現它確實變得更快，響應也更迅速（比如在中斷它的時候，它能更快地停下來）。而且隨著網格尺寸的壯大，它也不會經常性地陷於“停頓”狀態。因此，線程的處理又多了一項新的考慮因素：必須隨時檢查自己有沒有“太多的線程”（無論對什麼程序和運行平臺）。若線程太多，必須試著使用上面介紹的技術，對程序中的線程數量進行“平衡”。如果在一個多線程的程序中遇到了性能上的問題，那麼現在有許多因素需要檢查：

(1) 對`sleep`，`yield()`以及／或者`wait()`的呼叫足夠多嗎？

(2) `sleep()`的呼叫時間足夠長嗎？

(3) 運行的線程數是不是太多？

(4) 試過不同的平臺和JVM嗎？

象這樣的一些問題是造成多線程應用程序的編製成為一種“技術活”的原因之一。


# 14.6 總結


何時使用多線程技術，以及何時避免用它，這是我們需要掌握的重要課題。骼它的主要目的是對大量任務進行有序的管理。通過多個任務的混合使用，可以更有效地利用計算機資源，或者對用戶來說顯得更方便。資源均衡的經典問題是在IO等候期間如何利用CPU。至於用戶方面的方便性，最經典的問題就是如何在一個長時間的下載過程中監視並靈敏地反應一個“停止”（`stop`）按鈕的按下。
多線程的主要缺點包括：

(1) 等候使用共享資源時造成程序的運行速度變慢。

(2) 對線程進行管理要求的額外CPU開銷。

(3) 複雜程度無意義的加大，比如用獨立的線程來更新數組內每個元素的愚蠢主意。

(4) 漫長的等待、浪費精力的資源競爭以及死鎖等多線程症狀。

線程另一個優點是它們用“輕度”執行切換（100條指令的順序）取代了“重度”進程場景切換（1000條指令）。由於一個進程內的所有線程共享相同的內存空間，所以“輕度”場景切換隻改變程序的執行和本地變量。而在“重度”場景切換時，一個進程的改變要求必須完整地交換內存空間。

線程處理看來好象進入了一個全新的領域，似乎要求我們學習一種全新的程序設計語言——或者至少學習一系列新的語言概念。由於大多數微機操作系統都提供了對線程的支持，所以程序設計語言或者庫裡也出現了對線程的擴展。不管在什麼情況下，涉及線程的程序設計：

(1) 剛開始會讓人摸不著頭腦，要求改換我們傳統的編程思路；

(2) 其他語言對線程的支持看來是類似的。所以一旦掌握了線程的概念，在其他環境也不會有太大的困難。儘管對線程的支持使Java語言的複雜程度多少有些增加，但請不要責怪Java。畢竟，利用線程可以做許多有益的事情。

多個線程可能共享同一個資源（比如一個物件裡的內存），這是運用線程時面臨的最大的一個麻煩。必須保證多個線程不會同時試圖讀取和修改那個資源。這要求技巧性地運用`synchronized`（同步）關鍵字。它是一個有用的工具，但必須真正掌握它，因為假若操作不當，極易出現死鎖。

除此以外，運用線程時還要注意一個非常特殊的問題。由於根據Java的設計，它允許我們根據需要創建任意數量的線程——至少理論上如此（例如，假設為一項工程方面的有限元素分析創建數以百萬的線程，這對Java來說並非實際）。然而，我們一般都要控制自己創建的線程數量的上限。因為在某些情況下，大量線程會將場面變得一團糟，所以工作都會幾乎陷於停頓。臨界點並不像物件那樣可以達到幾千個，而是在100以下。一般情況下，我們只創建少數幾個關鍵線程，用它們解決某個特定的問題。這時數量的限制問題不大。但在較常規的一些設計中，這一限制確實會使我們感到束手束腳。

大家要注意線程處理中一個不是十分直觀的問題。由於採用了線程“調度”機制，所以通過在`run()`的主循環中插入對`sleep()`的呼叫，一般都可以使自己的程序運行得更快一些。這使它對編程技巧的要求非常高，特別是在更長的延遲似乎反而能提高性能的時候。當然，之所以會出現這種情況，是由於在正在運行的線程準備進入“休眠”狀態之前，較短的延遲可能造成“`sleep()`結束”調度機制的中斷。這便強迫調度機制將其中止，並於稍後重新啟動，以便它能做完自己的事情，再進入休眠狀態。必須多想一想，才能意識到事情真正的麻煩程度。

本章遺漏的一件事情是一個動畫例子，這是目前程序片最流行的一種應用。然而，Java JDK配套提供瞭解決這個問題的一整套方法（並可播放聲音），大家可到`java.sun.com`的演示區域下載。此外，我們完全有理由相信未來版本的Java會提供更好的動畫支持——儘管目前的Web湧現出了與傳統方式完全不同的非Java、非程序化的許多動畫方法。如果想系統學習Java動畫的工作原理，可參考《Core Java——核心Java》一書，由Cornell&Horstmann編著，Prentice-Hall於1997年出版。若欲更深入地瞭解線程處理，請參考《Concurrent Programming in Java——Java中的併發編程》，由Doug Lea編著，Addison-Wiseley於1997年出版；或者《Java Threads——Java線程》，Oaks&Wong編著，O'Reilly於1997年出版。


# 14.7 練習


(1) 從`Thread`繼承一個類，並（重載）覆蓋`run()`方法。在`run()`內，打印出一則訊息，然後呼叫`sleep()`。重複三遍這些操作，然後從`run()`返回。在構造器中放置一條啟動訊息，並覆蓋`finalize()`，打印一條關閉訊息。創建一個獨立的線程類，使它在`run()`內呼叫`System.gc()`和`System.runFinalization()`，並打印一則訊息，表明呼叫成功。創建這兩種類型的幾個線程，然後運行它們，看看會發生什麼。

(2) 修改`Counter2.java`，使線程成為一個內部類，而且不需要明確保存指向`Counter2`的一個。

(3) 修改`Sharing2.java`，在`TwoCounter`的`run()`方法內部添加一個`synchronized`（同步）塊，而不是同步整個`run()`方法。

(4) 創建兩個`Thread`子類，第一個的`run()`方法用於最開始的啟動，並捕獲第二個`Thread`物件的引用，然後呼叫`wait()`。第二個類的`run()`應在過幾秒後為第一個線程呼叫`modifyAll()`，使第一個線程能打印出一則訊息。

(5) 在`Ticker2`內的`Counter5.java`中，刪除`yield()`，並解釋一下結果。用一個`sleep()`換掉`yield()`，再解釋一下結果。

(6) 在`ThreadGroup1.java`中，將對`sys.suspend()`的呼叫換成對線程組的一個`wait()`呼叫，令其等候2秒鐘。為了保證獲得正確的結果，必須在一個同步塊內取得`sys`的物件鎖。

(7) 修改`Daemons.java`，使`main()`有一個`sleep()`，而不是一個`readLine()`。實驗不同的睡眠時間，看看會有什麼發生。

(8) 到第7章（中間部分）找到那個`GreenhouseControls.java`例子，它應該由三個文件構成。在`Event.java`中，`Event`類建立在對時間的監視基礎上。修改這個`Event`，使其成為一個線程。然後修改其餘的設計，使它們能與新的、以線程為基礎的Event正常協作。
