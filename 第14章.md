# 第14章 多執行緒


利用物件，可將一個程序分割成相互獨立的區域。我們通常也需要將一個程序轉換成多個獨立運行的子任務。

象這樣的每個子任務都叫作一個“執行緒”（`Thread`）。編寫程序時，可將每個執行緒都想象成獨立運行，而且都有自己的專用CPU。一些基礎機制實際會為我們自動分割CPU的時間。我們通常不必關心這些細節問題，所以多執行緒的程式碼編寫是相當簡便的。

這時理解一些定義對以後的學習狠有幫助。“進程”是指一種“自包容”的運行程序，有自己的地址空間。“多任務”操作系統能同時運行多個進程（程序）——但實際是由於CPU分時機制的作用，使每個進程都能循環獲得自己的CPU時間片。但由於輪換速度非常快，使得所有程序好象是在“同時”運行一樣。“執行緒”是進程內部單一的一個順序控制流。因此，一個進程可能容納了多個同時執行的執行緒。

多執行緒的應用範圍很廣。但在一般情況下，程序的一些部分同特定的事件或資源聯繫在一起，同時又不想為它而暫停程序其他部分的執行。這樣一來，就可考慮創建一個執行緒，令其與那個事件或資源關聯到一起，並讓它獨立於主程序運行。一個很好的例子便是“Quit”或“退出”按鈕——我們並不希望在程序的每一部分程式碼中都輪詢這個按鈕，同時又希望該按鈕能及時地作出響應（使程序看起來似乎經常都在輪詢它）。事實上，多執行緒最主要的一個用途就是構建一個“反應靈敏”的用戶界面。


# 14.1 反應靈敏的用戶界面

作為我們的起點，請思考一個需要執行某些CPU密集型計算的程序。由於CPU“全心全意”為那些計算服務，所以對用戶的輸入十分遲鈍，幾乎沒有什麼反應。在這裡，我們用一個組合的applet/application（程序片／應用程序）來簡單顯示出一個計數器的結果：

```
//: Counter1.java
// A non-responsive user interface
package c14;
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

public class Counter1 extends Applet {
  private int count = 0;
  private Button
    onOff = new Button("Toggle"),
    start = new Button("Start");
  private TextField t = new TextField(10);
  private boolean runFlag = true;
  public void init() {
    add(t);
    start.addActionListener(new StartL());
    add(start);
    onOff.addActionListener(new OnOffL());
    add(onOff);
  }
  public void go() {
    while (true) {
      try {
        Thread.currentThread().sleep(100);
      } catch (InterruptedException e){}
      if(runFlag)
        t.setText(Integer.toString(count++));
    }
  }
  class StartL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      go();
    }
  }
  class OnOffL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      runFlag = !runFlag;
    }
  }
  public static void main(String[] args) {
    Counter1 applet = new Counter1();
    Frame aFrame = new Frame("Counter1");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(300,200);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

在這個程序中，AWT和程序片程式碼都應是大家熟悉的，第13章對此已有很詳細的交待。`go()`方法正是程序全心全意服務的對待：將當前的`count`（計數）值置入`TextField`（文本字段）`t`，然後使`count`自增。

`go()`內的部分無限循環是呼叫`sleep()`。`sleep()`必須同一個`Thread`（執行緒）物件關聯到一起，而且似乎每個應用程序都有部分執行緒同它關聯（事實上，Java本身就是建立在執行緒基礎上的，肯定有一些執行緒會伴隨我們寫的應用一起運行）。所以無論我們是否明確使用了執行緒，都可利用`Thread.currentThread()`產生由程序使用的當前執行緒，然後為那個執行緒呼叫`sleep()`。注意，`Thread.currentThread()`是`Thread`類的一個靜態方法。

注意`sleep()`可能“拋”出一個`InterruptException`（中斷異常）——儘管產生這樣的異常被認為是中止執行緒的一種“惡意”手段，而且應該儘可能地杜絕這一做法。再次提醒大家，異常是為異常情況而產生的，而不是為了正常的控制流。在這裡包含了對一個“睡眠”執行緒的中斷，以支持未來的一種語言特性。

一旦按下`start`按鈕，就會呼叫`go()`。研究一下`go()`，你可能會很自然地（就象我一樣）認為它該支持多執行緒，因為它會進入“睡眠”狀態。也就是說，儘管方法本身“睡著”了，CPU仍然應該忙於監視其他按鈕“按下”事件。但有一個問題，那就是`go()`是永遠不會返回的，因為它被設計成一個無限循環。這意味著`actionPerformed()`根本不會返回。由於在第一個按鍵以後便陷入`actionPerformed()`中，所以程序不能再對其他任何事件進行控制（如果想出來，必須以某種方式“殺死”進程——最簡便的方式就是在控制檯窗口按`Ctrl+C`鍵）。

這裡最基本的問題是`go()`需要繼續執行自己的操作，而與此同時，它也需要返回，以便`actionPerformed()`能夠完成，而且用戶界面也能繼續響應用戶的操作。但物件`go()`這樣的傳統方法來說，它卻不能在繼續的同時將控制權返回給程序的其他部分。這聽起來似乎是一件不可能做到的事情，就象CPU必須同時位於兩個地方一樣，但執行緒可以解決一切。“執行緒模型”（以及Java中的編程支持）是一種程序編寫規範，可在單獨一個程序裡實作幾個操作的同時進行。根據這一機制，CPU可為每個執行緒都分配自己的一部分時間。每個執行緒都“感覺”自己好象擁有整個CPU，但CPU的計算時間實際卻是在所有執行緒間分攤的。

執行緒機制多少降低了一些計算效率，但無論程序的設計，資源的均衡，還是用戶操作的方便性，都從中獲得了巨大的利益。綜合考慮，這一機制是非常有價值的。當然，如果本來就安裝了多塊CPU，那麼操作系統能夠自行決定為不同的CPU分配哪些執行緒，程序的總體運行速度也會變得更快（所有這些都要求操作系統以及應用程序的支持）。多執行緒和多任務是充分發揮多處理機系統能力的一種最有效的方式。

## 14.1.1 從執行緒繼承

為創建一個執行緒，最簡單的方法就是從`Thread`類繼承。這個類包含了創建和運行執行緒所需的一切東西。`Thread`最重要的方法是`run()`。但為了使用`run()`，必須對其進行重載或者覆蓋，使其能充分按自己的吩咐行事。因此，`run()`屬於那些會與程序中的其他執行緒“併發”或“同時”執行的程式碼。

下面這個例子可創建任意數量的執行緒，並通過為每個執行緒分配一個獨一無二的編號（由一個靜態變量產生），從而對不同的執行緒進行跟蹤。`Thread`的`run()`方法在這裡得到了覆蓋，每通過一次循環，計數就減1——計數為0時則完成循環（此時一旦返回run()，執行緒就中止運行）。

```
//: SimpleThread.java
// Very simple Threading example

public class SimpleThread extends Thread {
  private int countDown = 5;
  private int threadNumber;
  private static int threadCount = 0;
  public SimpleThread() {
    threadNumber = ++threadCount;
    System.out.println("Making " + threadNumber);
  }
  public void run() {
    while(true) {
      System.out.println("Thread " +
        threadNumber + "(" + countDown + ")");
      if(--countDown == 0) return;
    }
  }
  public static void main(String[] args) {
    for(int i = 0; i < 5; i++)
      new SimpleThread().start();
    System.out.println("All Threads Started");
  }
} ///:~
```

`run()`方法幾乎肯定含有某種形式的循環——它們會一直持續到執行緒不再需要為止。因此，我們必須規定特定的條件，以便中斷並退出這個循環（或者在上述的例子中，簡單地從`run()`返回即可）。`run()`通常採用一種無限循環的形式。也就是說，通過阻止外部發出對執行緒的`stop()`或者`destroy()`呼叫，它會永遠運行下去（直到程序完成）。

在`main()`中，可看到創建並運行了大量執行緒。`Thread`包含了一個特殊的方法，叫作`start()`，它的作用是對執行緒進行特殊的初始化，然後呼叫`run()`。所以整個步驟包括：呼叫建構子來構建物件，然後用`start()`配置執行緒，再呼叫`run()`。如果不呼叫`start()`——如果適當的話，可在建構子那樣做——執行緒便永遠不會啟動。

下面是該程序某一次運行的輸出（注意每次運行都會不同）：

```
Making 1
Making 2
Making 3
Making 4
Making 5
Thread 1(5)
Thread 1(4)
Thread 1(3)
Thread 1(2)
Thread 2(5)
Thread 2(4)
Thread 2(3)
Thread 2(2)
Thread 2(1)
Thread 1(1)
All Threads Started
Thread 3(5)
Thread 4(5)
Thread 4(4)
Thread 4(3)
Thread 4(2)
Thread 4(1)
Thread 5(5)
Thread 5(4)
Thread 5(3)
Thread 5(2)
Thread 5(1)
Thread 3(4)
Thread 3(3)
Thread 3(2)
Thread 3(1)
```

可注意到這個例子中到處都呼叫了`sleep()`，然而輸出結果指出每個執行緒都獲得了屬於自己的那一部分CPU執行時間。從中可以看出，儘管`sleep()`依賴一個執行緒的存在來執行，但卻與允許或禁止執行緒無關。它只不過是另一個不同的方法而已。

亦可看出執行緒並不是按它們創建時的順序運行的。事實上，CPU處理一個現有執行緒集的順序是不確定的——除非我們親自介入，並用`Thread`的`setPriority()`方法調整它們的優先級。

`main()`創建`Thread`物件時，它並未捕獲任何一個物件的引用。普通物件對於垃圾收集來說是一種“公平競賽”，但執行緒卻並非如此。每個執行緒都會“註冊”自己，所以某處實際存在著對它的一個引用。這樣一來，垃圾收集器便只好對它“瞠目以對”了。

## 14.1.2 針對用戶界面的多執行緒

現在，我們也許能用一個執行緒解決在`Counter1.java`中出現的問題。採用的一個技巧便是在一個執行緒的`run()`方法中放置“子任務”——亦即位於`go()`內的循環。一旦用戶按下`Start`按鈕，執行緒就會啟動，但馬上結束執行緒的創建。這樣一來，儘管執行緒仍在運行，但程序的主要工作卻能得以繼續（等候並響應用戶界面的事件）。下面是具體的程式碼：

```
//: Counter2.java
// A responsive user interface with threads
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

class SeparateSubTask extends Thread {
  private int count = 0;
  private Counter2 c2;
  private boolean runFlag = true;
  public SeparateSubTask(Counter2 c2) {
    this.c2 = c2;
    start();
  }
  public void invertFlag() { runFlag = !runFlag;}
  public void run() {
    while (true) {
     try {
      sleep(100);
     } catch (InterruptedException e){}
     if(runFlag)
       c2.t.setText(Integer.toString(count++));
    }
  }
}

public class Counter2 extends Applet {
  TextField t = new TextField(10);
  private SeparateSubTask sp = null;
  private Button
    onOff = new Button("Toggle"),
    start = new Button("Start");
  public void init() {
    add(t);
    start.addActionListener(new StartL());
    add(start);
    onOff.addActionListener(new OnOffL());
    add(onOff);
  }
  class StartL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      if(sp == null)
        sp = new SeparateSubTask(Counter2.this);
    }
  }
  class OnOffL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      if(sp != null)
        sp.invertFlag();
    }
  }
  public static void main(String[] args) {
    Counter2 applet = new Counter2();
    Frame aFrame = new Frame("Counter2");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(300,200);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

現在，`Counter2`變成了一個相當直接的程序，它的唯一任務就是設置並管理用戶界面。但假若用戶現在按下`Start`按鈕，卻不會真正呼叫一個方法。此時不是創建類的一個執行緒，而是創建`SeparateSubTask`，然後繼續`Counter2`事件循環。注意此時會保存`SeparateSubTask`的引用，以便我們按下`onOff`按鈕的時候，能正常地切換位於`SeparateSubTask`內部的`runFlag`（運行標誌）。隨後那個執行緒便可啟動（當它看到標誌的時候），然後將自己中止（亦可將`SeparateSubTask`設為一個內部類來達到這一目的）。

`SeparateSubTask`類是對`Thread`的一個簡單擴展，它帶有一個建構子（其中保存了`Counter2`引用，然後通過呼叫`start()`來運行執行緒）以及一個`run()`——本質上包含了`Counter1.java`的`go()`內的程式碼。由於`SeparateSubTask`知道自己容納了指向一個`Counter2`的引用，所以能夠在需要的時候介入，並訪問`Counter2`的`TestField`（文本字段）。

按下`onOff`按鈕，幾乎立即能得到正確的響應。當然，這個響應其實並不是“立即”發生的，它畢竟和那種由“中斷”驅動的系統不同。只有執行緒擁有CPU的執行時間，並注意到標記已發生改變，計數器才會停止。

(1) 用內部類改善程式碼

下面說說題外話，請大家注意一下`SeparateSubTask`和`Counter2`類之間發生的結合行為。`SeparateSubTask`同`Counter2`“親密”地結合到了一起——它必須持有指向自己“父”`Counter2`物件的一個引用，以便自己能回調和操縱它。但兩個類並不是真的合併為單獨一個類（儘管在下一節中，我們會講到Java確實提供了合併它們的方法），因為它們各自做的是不同的事情，而且是在不同的時間創建的。但不管怎樣，它們依然緊密地結合到一起（更準確地說，應該叫“聯合”），所以使程序程式碼多少顯得有些笨拙。在這種情況下，一個內部類可以顯著改善程式碼的“可讀性”和執行效率：

```
//: Counter2i.java
// Counter2 using an inner class for the thread
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

public class Counter2i extends Applet {
  private class SeparateSubTask extends Thread {
    int count = 0;
    boolean runFlag = true;
    SeparateSubTask() { start(); }
    public void run() {
      while (true) {
       try {
        sleep(100);
       } catch (InterruptedException e){}
       if(runFlag)
         t.setText(Integer.toString(count++));
      }
    }
  }
  private SeparateSubTask sp = null;
  private TextField t = new TextField(10);
  private Button
    onOff = new Button("Toggle"),
    start = new Button("Start");
  public void init() {
    add(t);
    start.addActionListener(new StartL());
    add(start);
    onOff.addActionListener(new OnOffL());
    add(onOff);
  }
  class StartL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      if(sp == null)
        sp = new SeparateSubTask();
    }
  }
  class OnOffL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      if(sp != null)
        sp.runFlag = !sp.runFlag; // invertFlag();
    }
  }
  public static void main(String[] args) {
    Counter2i applet = new Counter2i();
    Frame aFrame = new Frame("Counter2i");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(300,200);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

這個`SeparateSubTask`名字不會與前例中的`SeparateSubTask`衝突——即使它們都在相同的目錄裡——因為它已作為一個內部類隱藏起來。大家亦可看到內部類被設為`private`（私有）屬性，這意味著它的字段和方法都可獲得默認的訪問權限（`run()`除外，它必須設為`public`，因為它在基類中是公開的）。除`Counter2i`之外，其他任何方面都不可訪問`private`內部類。而且由於兩個類緊密結合在一起，所以很容易放寬它們之間的訪問限制。在`SeparateSubTask`中，我們可看到`invertFlag()`方法已被刪去，因為`Counter2i`現在可以直接訪問`runFlag`。

此外，注意`SeparateSubTask`的建構子已得到了簡化——它現在唯一的用外就是啟動執行緒。`Counter2i`物件的引用仍象以前那樣得以捕獲，但不再是通過人工傳遞和引用外部物件來達到這一目的，此時的內部類機制可以自動照料它。在`run()`中，可看到對`t`的訪問是直接進行的，似乎它是`SeparateSubTask`的一個字段。父類中的t字段現在可以變成`private`，因為`SeparateSubTask`能在未獲任何特殊許可的前提下自由地訪問它——而且無論如何都該儘可能地把字段變成“私有”屬性，以防來自類外的某種力量不慎地改變它們。

無論在什麼時候，只要注意到類相互之間結合得比較緊密，就可考慮利用內部類來改善程式碼的編寫與維護。

## 14.1.3 用主類合併執行緒

在上面的例子中，我們看到執行緒類（`Thread`）與程序的主類（`Main`）是分隔開的。這樣做非常合理，而且易於理解。然而，還有另一種方式也是經常要用到的。儘管它不十分明確，但一般都要更簡潔一些（這也解釋了它為什麼十分流行）。通過將主程序類變成一個執行緒，這種形式可將主程序類與執行緒類合併到一起。由於對一個GUI程序來說，主程序類必須從`Frame`或`Applet`繼承，所以必須用一個界面加入額外的功能。這個界面叫作`Runnable`，其中包含了與`Thread`一致的基本方法。事實上，`Thread`也實作了`Runnable`，它只指出有一個`run()`方法。

對合並後的程序／執行緒來說，它的用法不是十分明確。當我們啟動程序時，會創建一個`Runnable`（可運行的）物件，但不會自行啟動執行緒。執行緒的啟動必須明確進行。下面這個程序向我們演示了這一點，它再現了`Counter2`的功能：

```
//: Counter3.java
// Using the Runnable interface to turn the
// main class into a thread.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

public class Counter3
    extends Applet implements Runnable {
  private int count = 0;
  private boolean runFlag = true;
  private Thread selfThread = null;
  private Button
    onOff = new Button("Toggle"),
    start = new Button("Start");
  private TextField t = new TextField(10);
  public void init() {
    add(t);
    start.addActionListener(new StartL());
    add(start);
    onOff.addActionListener(new OnOffL());
    add(onOff);
  }
  public void run() {
    while (true) {
      try {
        selfThread.sleep(100);
      } catch (InterruptedException e){}
      if(runFlag)
        t.setText(Integer.toString(count++));
    }
  }
  class StartL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      if(selfThread == null) {
        selfThread = new Thread(Counter3.this);
        selfThread.start();
      }
    }
  }
  class OnOffL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      runFlag = !runFlag;
    }
  }
  public static void main(String[] args) {
    Counter3 applet = new Counter3();
    Frame aFrame = new Frame("Counter3");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(300,200);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

現在`run()`位於類內，但它在`init()`結束以後仍處在“睡眠”狀態。若按下啟動按鈕，執行緒便會用多少有些曖昧的表達方式創建（若執行緒尚不存在）：

```
new Thread(Counter3.this);
```

若某樣東西有一個`Runnable`界面，實際只是意味著它有一個`run()`方法，但不存在與之相關的任何特殊東西——它不具有任何天生的執行緒處理能力，這與那些從`Thread`繼承的類是不同的。所以為了從一個`Runnable`物件產生執行緒，必須單獨創建一個執行緒，併為其傳遞`Runnable`物件；可為其使用一個特殊的建構子，並令其採用一個`Runnable`作為自己的參數使用。隨後便可為那個執行緒呼叫`start()`，如下所示：

```
selfThread.start();
```

它的作用是執行常規初始化操作，然後呼叫`run()`。

`Runnable`界面最大的一個優點是所有東西都從屬於相同的類。若需訪問什麼東西，只需簡單地訪問它即可，不需要涉及一個獨立的物件。但為這種便利也是要付出代價的——只可為那個特定的物件運行單獨一個執行緒（儘管可創建那種類型的多個物件，或者在不同的類裡創建其他物件）。

注意`Runnable`界面本身並不是造成這一限制的罪魁禍首。它是由於`Runnable`與我們的主類合併造成的，因為每個應用只能主類的一個物件。

## 14.1.4 製作多個執行緒

現在考慮一下創建多個不同的執行緒的問題。我們不可用前面的例子來做到這一點，所以必須倒退回去，利用從`Thread`繼承的多個獨立類來封裝`run()`。但這是一種更常規的方法，而且更易理解，所以儘管前例揭示了我們經常都能看到的編碼樣式，但並不推薦在大多數情況下都那樣做，因為它只是稍微複雜一些，而且靈活性稍低一些。

下面這個例子用計數器和切換按鈕再現了前面的編碼樣式。但這一次，一個特定計數器的所有信息（按鈕和文本字段）都位於它自己的、從`Thread`繼承的物件內。`Ticker`中的所有字段都具有`private`（私有）屬性，這意味著`Ticker`的具體實作方法可根據實際情況任意修改，其中包括修改用於獲取和顯示信息的數據組件的數量及類型。創建好一個`Ticker`物件以後，建構子便請求一個AWT容器（`Container`）的引用——`Ticker`用自己的可視組件填充那個容器。採用這種方式，以後一旦改變了可視組件，使用`Ticker`的程式碼便不需要另行修改一道。

```
//: Counter4.java
// If you separate your thread from the main
// class, you can have as many threads as you
// want.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

class Ticker extends Thread {
  private Button b = new Button("Toggle");
  private TextField t = new TextField(10);
  private int count = 0;
  private boolean runFlag = true;
  public Ticker(Container c) {
    b.addActionListener(new ToggleL());
    Panel p = new Panel();
    p.add(t);
    p.add(b);
    c.add(p);
  }
  class ToggleL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      runFlag = !runFlag;
    }
  }
  public void run() {
    while (true) {
      if(runFlag)
        t.setText(Integer.toString(count++));
       try {
        sleep(100);
      } catch (InterruptedException e){}
    }
  }
}

public class Counter4 extends Applet {
  private Button start = new Button("Start");
  private boolean started = false;
  private Ticker[] s;
  private boolean isApplet = true;
  private int size;
  public void init() {
    // Get parameter "size" from Web page:
    if(isApplet)
      size =
        Integer.parseInt(getParameter("size"));
    s = new Ticker[size];
    for(int i = 0; i < s.length; i++)
      s[i] = new Ticker(this);
    start.addActionListener(new StartL());
    add(start);
  }
  class StartL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      if(!started) {
        started = true;
        for(int i = 0; i < s.length; i++)
          s[i].start();
      }
    }
  }
  public static void main(String[] args) {
    Counter4 applet = new Counter4();
    // This isn't an applet, so set the flag and
    // produce the parameter values from args:
    applet.isApplet = false;
    applet.size =
      (args.length == 0 ? 5 :
        Integer.parseInt(args[0]));
    Frame aFrame = new Frame("Counter4");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(200, applet.size * 50);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

`Ticker`不僅包括了自己的執行緒處理機制，也提供了控制與顯示執行緒的工具。可按自己的意願創建任意數量的執行緒，毋需明確地創建窗口化組件。

在`Counter4`中，有一個名為`s`的`Ticker`物件的數組。為獲得最大的靈活性，這個數組的長度是用程序片參數接觸Web頁而初始化的。下面是網頁中長度參數大致的樣子，它們嵌於對程序片（applet）的描述內容中：

```
<applet code=Counter4 width=600 height=600>
<param name=size value="20">
</applet>
```

其中，`param`，`name`和`value`是所有Web頁都適用的關鍵字。`name`是指程序中對參數的一種引用稱謂，`value`可以是任何字符串（並不僅僅是解析成一個數字的東西）。

我們注意到對數組`s`長度的判斷是在`init()`內部完成的，它沒有作為`s`的內嵌定義的一部分提供。換言之，不可將下述程式碼作為類定義的一部分使用（應該位於任何方法的外部）：

```
inst size = Integer.parseInt(getParameter("Size"));
Ticker[] s = new Ticker[size]
```

可把它編譯出來，但會在運行期得到一個空指針異常。但若將`getParameter()`初始化移入`init()`，則可正常工作。程序片框架會進行必要的啟動工作，以便在進入`init()`前收集好一些參數。

此外，上述程式碼被同時設置成一個程序片和一個應用（程序）。在它是應用程序的情況下，`size`參數可從命令行裡提取出來（否則就提供一個默認的值）。

數組的長度建好以後，就可以創建新的`Ticker`物件；作為`Ticker`建構子的一部分，用於每個`Ticker`的按鈕和文本字段就會加入程序片。

按下`Start`按鈕後，會在整個`Ticker`數組裡遍歷，併為每個`Ticker`呼叫`start()`。記住，`start()`會進行必要的執行緒初始化工作，然後為那個執行緒呼叫`run()`。

`ToggleL`監視器只是簡單地切換`Ticker`中的標記，一旦對應執行緒以後需要修改這個標記，它會作出相應的反應。

這個例子的一個好處是它使我們能夠方便地創建由單獨子任務構成的大型集合，並以監視它們的行為。在這種情況下，我們會發現隨著子任務數量的增多，機器顯示出來的數字可能會出現更大的分歧，這是由於為執行緒提供服務的方式造成的。

亦可試著體驗一下`sleep(100)`在`Ticker.run()`中的重要作用。若刪除`sleep()`，那麼在按下一個切換按鈕前，情況仍然會進展良好。按下按鈕以後，那個特定的執行緒就會出現一個失敗的`runFlag`，而且`run()`會深深地陷入一個無限循環——很難在多任務處理期間中止退出。因此，程序對用戶操作的反應靈敏度會大幅度降低。

## 14.1.5 Daemon執行緒

“Daemon”執行緒的作用是在程序的運行期間於後臺提供一種“常規”服務，但它並不屬於程序的一個基本部分。因此，一旦所有非Daemon執行緒完成，程序也會中止運行。相反，假若有任何非Daemon執行緒仍在運行（比如還有一個正在運行`main()`的執行緒），則程序的運行不會中止。

通過呼叫`isDaemon()`，可調查一個執行緒是不是一個Daemon，而且能用`setDaemon()`打開或者關閉一個執行緒的Daemon狀態。如果是一個Daemon執行緒，那麼它創建的任何執行緒也會自動具備Daemon屬性。

下面這個例子演示了Daemon執行緒的用法：

```
//: Daemons.java
// Daemonic behavior
import java.io.*;

class Daemon extends Thread {
  private static final int SIZE = 10;
  private Thread[] t = new Thread[SIZE];
  public Daemon() {
    setDaemon(true);
    start();
  }
  public void run() {
    for(int i = 0; i < SIZE; i++)
      t[i] = new DaemonSpawn(i);
    for(int i = 0; i < SIZE; i++)
      System.out.println(
        "t[" + i + "].isDaemon() = "
        + t[i].isDaemon());
    while(true)
      yield();
  }
}

class DaemonSpawn extends Thread {
  public DaemonSpawn(int i) {
    System.out.println(
      "DaemonSpawn " + i + " started");
    start();
  }
  public void run() {
    while(true)
      yield();
  }
}

public class Daemons {
  public static void main(String[] args) {
    Thread d = new Daemon();
    System.out.println(
      "d.isDaemon() = " + d.isDaemon());
    // Allow the daemon threads to finish
    // their startup processes:
    BufferedReader stdin =
      new BufferedReader(
        new InputStreamReader(System.in));
    System.out.println("Waiting for CR");
    try {
      stdin.readLine();
    } catch(IOException e) {}
  }
} ///:~
```

Daemon執行緒可將自己的Daemon標記設置成“真”，然後產生一系列其他執行緒，而且認為它們也具有Daemon屬性。隨後，它進入一個無限循環，在其中呼叫`yield()`，放棄對其他進程的控制。在這個程序早期的一個版本中，無限循環會使`int`計數器自增，但會使整個程序都好象陷入停頓狀態。換用`yield()`後，卻可使程序充滿“活力”，不會使人產生停滯或反應遲鈍的感覺。

一旦`main()`完成自己的工作，便沒有什麼能阻止程序中斷運行，因為這裡運行的只有Daemon執行緒。所以能看到啟動所有Daemon執行緒後顯示出來的結果，`System.in`也進行了相應的設置，使程序中斷前能等待一個回車。如果不進行這樣的設置，就只能看到創建Daemon執行緒的一部分結果（試試將`readLine()`程式碼換成不同長度的`sleep()`呼叫，看看會有什麼表現）。


# 14.2 共享有限的資源


可將單執行緒程序想象成一種孤立的實體，它能遍歷我們的問題空間，而且一次只能做一件事情。由於只有一個實體，所以永遠不必擔心會有兩個實體同時試圖使用相同的資源，就象兩個人同時都想停到一個車位，同時都想通過一扇門，甚至同時發話。

進入多執行緒環境後，它們則再也不是孤立的。可能會有兩個甚至更多的執行緒試圖同時同一個有限的資源。必須對這種潛在資源衝突進行預防，否則就可能發生兩個執行緒同時訪問一個銀行帳號，打印到同一臺計算機，以及對同一個值進行調整等等。

## 14.2.1 資源訪問的錯誤方法

現在考慮換成另一種方式來使用本章頻繁見到的計數器。在下面的例子中，每個執行緒都包含了兩個計數器，它們在`run()`裡自增以及顯示。除此以外，我們使用了`Watcher`類的另一個執行緒。它的作用是監視計數器，檢查它們是否保持相等。這表面是一項無意義的行動，因為如果查看程式碼，就會發現計數器肯定是相同的。但實際情況卻不一定如此。下面是程序的第一個版本：

```
//: Sharing1.java
// Problems with resource sharing while threading
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

class TwoCounter extends Thread {
  private boolean started = false;
  private TextField
    t1 = new TextField(5),
    t2 = new TextField(5);
  private Label l =
    new Label("count1 == count2");
  private int count1 = 0, count2 = 0;
  // Add the display components as a panel
  // to the given container:
  public TwoCounter(Container c) {
    Panel p = new Panel();
    p.add(t1);
    p.add(t2);
    p.add(l);
    c.add(p);
  }
  public void start() {
    if(!started) {
      started = true;
      super.start();
    }
  }
  public void run() {
    while (true) {
      t1.setText(Integer.toString(count1++));
      t2.setText(Integer.toString(count2++));
      try {
        sleep(500);
      } catch (InterruptedException e){}
    }
  }
  public void synchTest() {
    Sharing1.incrementAccess();
    if(count1 != count2)
      l.setText("Unsynched");
  }
}

class Watcher extends Thread {
  private Sharing1 p;
  public Watcher(Sharing1 p) {
    this.p = p;
    start();
  }
  public void run() {
    while(true) {
      for(int i = 0; i < p.s.length; i++)
        p.s[i].synchTest();
      try {
        sleep(500);
      } catch (InterruptedException e){}
    }
  }
}

public class Sharing1 extends Applet {
  TwoCounter[] s;
  private static int accessCount = 0;
  private static TextField aCount =
    new TextField("0", 10);
  public static void incrementAccess() {
    accessCount++;
    aCount.setText(Integer.toString(accessCount));
  }
  private Button
    start = new Button("Start"),
    observer = new Button("Observe");
  private boolean isApplet = true;
  private int numCounters = 0;
  private int numObservers = 0;
  public void init() {
    if(isApplet) {
      numCounters =
        Integer.parseInt(getParameter("size"));
      numObservers =
        Integer.parseInt(
          getParameter("observers"));
    }
    s = new TwoCounter[numCounters];
    for(int i = 0; i < s.length; i++)
      s[i] = new TwoCounter(this);
    Panel p = new Panel();
    start.addActionListener(new StartL());
    p.add(start);
    observer.addActionListener(new ObserverL());
    p.add(observer);
    p.add(new Label("Access Count"));
    p.add(aCount);
    add(p);
  }
  class StartL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      for(int i = 0; i < s.length; i++)
        s[i].start();
    }
  }
  class ObserverL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      for(int i = 0; i < numObservers; i++)
        new Watcher(Sharing1.this);
    }
  }
  public static void main(String[] args) {
    Sharing1 applet = new Sharing1();
    // This isn't an applet, so set the flag and
    // produce the parameter values from args:
    applet.isApplet = false;
    applet.numCounters =
      (args.length == 0 ? 5 :
        Integer.parseInt(args[0]));
    applet.numObservers =
      (args.length < 2 ? 5 :
        Integer.parseInt(args[1]));
    Frame aFrame = new Frame("Sharing1");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e){
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(350, applet.numCounters *100);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

和往常一樣，每個計數器都包含了自己的顯示組件：兩個文本字段以及一個標籤。根據它們的初始值，可知道計數是相同的。這些組件在`TwoCounter`建構子加入`Container`。由於這個執行緒是通過用戶的一個“按下按鈕”操作啟動的，所以`start()`可能被多次呼叫。但對一個執行緒來說，對`Thread.start()`的多次呼叫是非法的（會產生異常）。在`started`標記和重載的`start()`方法中，大家可看到針對這一情況採取的防範措施。

在`run()`中，`count1`和`count2`的自增與顯示方式表面上似乎能保持它們完全一致。隨後會呼叫`sleep()`；若沒有這個呼叫，程序便會出錯，因為那會造成CPU難於交換任務。

`synchTest()`方法採取的似乎是沒有意義的行動，它檢查`count1`是否等於`count2`；如果不等，就把標籤設為`"Unsynched"`（不同步）。但是首先，它呼叫的是類`Sharing1`的一個靜態成員，以便自增和顯示一個訪問計數器，指出這種檢查已成功進行了多少次（這樣做的理由會在本例的其他版本中變得非常明顯）。

`Watcher`類是一個執行緒，它的作用是為處於活動狀態的所有`TwoCounter`物件都呼叫`synchTest()`。其間，它會對`Sharing1`物件中容納的數組進行遍歷。可將`Watcher`想象成它掠過`TwoCounter`物件的肩膀不斷地“偷看”。

`Sharing1`包含了`TwoCounter`物件的一個數組，它通過`init()`進行初始化，並在我們按下`"start"`按鈕後作為執行緒啟動。以後若按下`"Observe"`（觀察）按鈕，就會創建一個或者多個觀察器，並對毫不設防的`TwoCounter`進行調查。

注意為了讓它作為一個程序片在瀏覽器中運行，Web頁需要包含下面這幾行：

```
<applet code=Sharing1 width=650 height=500>
<param name=size value="20">
<param name=observers value="1">
</applet>
```

可自行改變寬度、高度以及參數，根據自己的意願進行試驗。若改變了`size`和`observers`，程序的行為也會發生變化。我們也注意到，通過從命令行接受參數（或者使用默認值），它被設計成作為一個獨立的應用程序運行。

下面才是最讓人“不可思議”的。在`TwoCounter.run()`中，無限循環只是不斷地重複相鄰的行：

```
t1.setText(Integer.toString(count1++));
t2.setText(Integer.toString(count2++));
```

（和“睡眠”一樣，不過在這裡並不重要）。但在程序運行的時候，你會發現`count1`和`count2`被“觀察”（用`Watcher`觀察）的次數是不相等的！這是由執行緒的本質造成的——它們可在任何時候掛起（暫停）。所以在上述兩行的執行時刻之間，有時會出現執行暫停現象。同時，`Watcher`執行緒也正好跟隨著進來，並正好在這個時候進行比較，造成計數器出現不相等的情況。

本例揭示了使用執行緒時一個非常基本的問題。我們跟無從知道一個執行緒什麼時候運行。想象自己坐在一張桌子前面，桌上放有一把叉子，準備叉起自己的最後一塊食物。當叉子要碰到食物時，食物卻突然消失了（因為這個執行緒已被掛起，同時另一個執行緒進來“偷”走了食物）。這便是我們要解決的問題。

有的時候，我們並不介意一個資源在嘗試使用它的時候是否正被訪問（食物在另一些盤子裡）。但為了讓多執行緒機制能夠正常運轉，需要採取一些措施來防止兩個執行緒訪問相同的資源——至少在關鍵的時期。

為防止出現這樣的衝突，只需在執行緒使用一個資源時為其加鎖即可。訪問資源的第一個執行緒會其加上鎖以後，其他執行緒便不能再使用那個資源，除非被解鎖。如果車子的前座是有限的資源，高喊“這是我的！”的孩子會主張把它鎖起來。

## 14.2.2 Java如何共享資源

對一種特殊的資源——物件中的內存——Java提供了內建的機制來防止它們的衝突。由於我們通常將數據元素設為從屬於`private`（私有）類，然後只通過方法訪問那些內存，所以只需將一個特定的方法設為`synchronized`（同步的），便可有效地防止衝突。在任何時刻，只可有一個執行緒呼叫特定物件的一個`synchronized`方法（儘管那個執行緒可以呼叫多個物件的同步方法）。下面列出簡單的s`ynchronized`方法：


```
synchronized void f() { /* ... */ }
synchronized void g() { /* ... */ }
```

每個物件都包含了一把鎖（也叫作“監視器”），它自動成為物件的一部分（不必為此寫任何特殊的程式碼）。呼叫任何`synchronized`方法時，物件就會被鎖定，不可再呼叫那個物件的其他任何`synchronized`方法，除非第一個方法完成了自己的工作，並解除鎖定。在上面的例子中，如果為一個物件呼叫`f()`，便不能再為同樣的物件呼叫`g()`，除非`f()`完成並解除鎖定。因此，一個特定物件的所有`synchronized`方法都共享著一把鎖，而且這把鎖能防止多個方法對通用內存同時進行寫操作（比如同時有多個執行緒）。

每個類也有自己的一把鎖（作為類的`Class`物件的一部分），所以`synchronized static`方法可在一個類的範圍內被相互間鎖定起來，防止與`static`數據的接觸。

注意如果想保護其他某些資源不被多個執行緒同時訪問，可以強制通過`synchronized`方訪問那些資源。

(1) 計數器的同步

裝備了這個新關鍵字後，我們能夠採取的方法就更靈活了：可以只為`TwoCounter`中的方法簡單地使用`synchronized`關鍵字。下面這個例子是對前例的改版，其中加入了新的關鍵字：

```
//: Sharing2.java
// Using the synchronized keyword to prevent
// multiple access to a particular resource.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

class TwoCounter2 extends Thread {
  private boolean started = false;
  private TextField
    t1 = new TextField(5),
    t2 = new TextField(5);
  private Label l =
    new Label("count1 == count2");
  private int count1 = 0, count2 = 0;
  public TwoCounter2(Container c) {
    Panel p = new Panel();
    p.add(t1);
    p.add(t2);
    p.add(l);
    c.add(p);
  }    
  public void start() {
    if(!started) {
      started = true;
      super.start();
    }
  }
  public synchronized void run() {
    while (true) {
      t1.setText(Integer.toString(count1++));
      t2.setText(Integer.toString(count2++));
      try {
        sleep(500);
      } catch (InterruptedException e){}
    }
  }
  public synchronized void synchTest() {
    Sharing2.incrementAccess();
    if(count1 != count2)
      l.setText("Unsynched");
  }
}

class Watcher2 extends Thread {
  private Sharing2 p;
  public Watcher2(Sharing2 p) {
    this.p = p;
    start();
  }
  public void run() {
    while(true) {
      for(int i = 0; i < p.s.length; i++)
        p.s[i].synchTest();
      try {
        sleep(500);
      } catch (InterruptedException e){}
    }
  }
}

public class Sharing2 extends Applet {
  TwoCounter2[] s;
  private static int accessCount = 0;
  private static TextField aCount =
    new TextField("0", 10);
  public static void incrementAccess() {
    accessCount++;
    aCount.setText(Integer.toString(accessCount));
  }
  private Button
    start = new Button("Start"),
    observer = new Button("Observe");
  private boolean isApplet = true;
  private int numCounters = 0;
  private int numObservers = 0;
  public void init() {
    if(isApplet) {
      numCounters =
        Integer.parseInt(getParameter("size"));
      numObservers =
        Integer.parseInt(
          getParameter("observers"));
    }
    s = new TwoCounter2[numCounters];
    for(int i = 0; i < s.length; i++)
      s[i] = new TwoCounter2(this);
    Panel p = new Panel();
    start.addActionListener(new StartL());
    p.add(start);
    observer.addActionListener(new ObserverL());
    p.add(observer);
    p.add(new Label("Access Count"));
    p.add(aCount);
    add(p);
  }
  class StartL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      for(int i = 0; i < s.length; i++)
        s[i].start();
    }
  }
  class ObserverL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      for(int i = 0; i < numObservers; i++)
        new Watcher2(Sharing2.this);
    }
  }
  public static void main(String[] args) {
    Sharing2 applet = new Sharing2();
    // This isn't an applet, so set the flag and
    // produce the parameter values from args:
    applet.isApplet = false;
    applet.numCounters =
      (args.length == 0 ? 5 :
        Integer.parseInt(args[0]));
    applet.numObservers =
      (args.length < 2 ? 5 :
        Integer.parseInt(args[1]));
    Frame aFrame = new Frame("Sharing2");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e){
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(350, applet.numCounters *100);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

我們注意到無論`run()`還是`synchTest()`都是“同步的”。如果只同步其中的一個方法，那麼另一個就可以自由忽視物件的鎖定，並可無礙地呼叫。所以必須記住一個重要的規則：對於訪問某個關鍵共享資源的所有方法，都必須把它們設為`synchronized`，否則就不能正常地工作。

現在又遇到了一個新問題。`Watcher2`永遠都不能看到正在進行的事情，因為整個`run()`方法已設為“同步”。而且由於肯定要為每個物件運行`run()`，所以鎖永遠不能打開，而`synchTest()`永遠不會得到呼叫。之所以能看到這一結果，是因為`accessCount`根本沒有變化。

為解決這個問題，我們能採取的一個辦法是隻將`run()`中的一部分程式碼隔離出來。想用這個辦法隔離出來的那部分程式碼叫作“關鍵區域”，而且要用不同的方式來使用`synchronized`關鍵字，以設置一個關鍵區域。Java通過“同步塊”提供對關鍵區域的支持；這一次，我們用`synchronized`關鍵字指出物件的鎖用於對其中封閉的程式碼進行同步。如下所示：

```
synchronized(syncObject) {
  // This code can be accessed by only
  // one thread at a time, assuming all
  // threads respect syncObject's lock
}
```

在能進入同步塊之前，必須在`synchObject`上取得鎖。如果已有其他執行緒取得了這把鎖，塊便不能進入，必須等候那把鎖被釋放。

可從整個`run()`中刪除`synchronized`關鍵字，換成用一個同步塊包圍兩個關鍵行，從而完成對`Sharing2`例子的修改。但什麼物件應作為鎖來使用呢？那個物件已由`synchTest()`標記出來了——也就是當前物件（`this`）！所以修改過的`run()`方法象下面這個樣子：

```
  public void run() {
    while (true) {
      synchronized(this) {
        t1.setText(Integer.toString(count1++));
        t2.setText(Integer.toString(count2++));
      }
      try {
        sleep(500);
      } catch (InterruptedException e){}
    }
  }
```

這是必須對`Sharing2.java`作出的唯一修改，我們會看到儘管兩個計數器永遠不會脫離同步（取決於允許`Watcher`什麼時候檢查它們），但在`run()`執行期間，仍然向`Watcher`提供了足夠的訪問權限。

當然，所有同步都取決於程序員是否勤奮：要訪問共享資源的每一部分程式碼都必須封裝到一個適當的同步塊裡。

(2) 同步的效率

由於要為同樣的數據編寫兩個方法，所以無論如何都不會給人留下效率很高的印象。看來似乎更好的一種做法是將所有方法都設為自動同步，並完全消除`synchronized`關鍵字（當然，含有`synchronized run()`的例子顯示出這樣做是很不通的）。但它也揭示出獲取一把鎖並非一種“廉價”方法——為一次方法呼叫付出的代價（進入和退出方法，不執行方法主體）至少要累加到四倍，而且根據我們的具體現方法，這一代價還有可能變得更高。所以假如已知一個方法不會造成衝突，最明智的做法便是撤消其中的`synchronized`關鍵字。

## 14.2.3 回顧Java Beans

我們現在已理解了同步，接著可換從另一個角度來考察Java Beans。無論什麼時候創建了一個Bean，就必須假定它要在一個多執行緒的環境中運行。這意味著：

(1) 只要可行，Bean的所有公共方法都應同步。當然，這也帶來了“同步”在運行期間的開銷。若特別在意這個問題，在關鍵區域中不會造成問題的方法就可保留為“不同步”，但注意這通常都不是十分容易判斷。有資格的方法傾向於規模很小（如下例的`getCircleSize()`）以及／或者“微小”。也就是說，這個方法呼叫在如此少的程式碼片裡執行，以至於在執行期間物件不能改變。如果將這種方法設為“不同步”，可能對程序的執行速度不會有明顯的影響。可能也將一個Bean的所有`public`方法都設為`synchronized`，並只有在保證特別必要、而且會造成一個差異的情況下，才將`synchronized`關鍵字刪去。

(2) 如果將一個多轉換事件送給一系列對那個事件感興趣的“聽眾”，必須假在列表中移動的時候可以添加或者刪除。

第一點很容易處理，但第二點需要考慮更多的東西。讓我們以前一章提供的`BangBean.java`為例。在那個例子中，我們忽略了`synchronized`關鍵字（那時還沒有引入呢），並將轉換設為單轉換，從而回避了多執行緒的問題。在下面這個修改過的版本中，我們使其能在多執行緒環境中工作，併為事件採用了多轉換技術：

```
//: BangBean2.java
// You should write your Beans this way so they
// can run in a multithreaded environment.
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.io.*;

public class BangBean2 extends Canvas
    implements Serializable {
  private int xm, ym;
  private int cSize = 20; // Circle size
  private String text = "Bang!";
  private int fontSize = 48;
  private Color tColor = Color.red;
  private Vector actionListeners = new Vector();
  public BangBean2() {
    addMouseListener(new ML());
    addMouseMotionListener(new MM());
  }
  public synchronized int getCircleSize() {
    return cSize;
  }
  public synchronized void
  setCircleSize(int newSize) {
    cSize = newSize;
  }
  public synchronized String getBangText() {
    return text;
  }
  public synchronized void
  setBangText(String newText) {
    text = newText;
  }
  public synchronized int getFontSize() {
    return fontSize;
  }
  public synchronized void
  setFontSize(int newSize) {
    fontSize = newSize;
  }
  public synchronized Color getTextColor() {
    return tColor;
  }
  public synchronized void
  setTextColor(Color newColor) {
    tColor = newColor;
  }
  public void paint(Graphics g) {
    g.setColor(Color.black);
    g.drawOval(xm - cSize/2, ym - cSize/2,
      cSize, cSize);
  }
  // This is a multicast listener, which is
  // more typically used than the unicast
  // approach taken in BangBean.java:
  public synchronized void addActionListener (
      ActionListener l) {
    actionListeners.addElement(l);
  }
  public synchronized void removeActionListener(
      ActionListener l) {
    actionListeners.removeElement(l);
  }
  // Notice this isn't synchronized:
  public void notifyListeners() {
    ActionEvent a =
      new ActionEvent(BangBean2.this,
        ActionEvent.ACTION_PERFORMED, null);
    Vector lv = null;
    // Make a copy of the vector in case someone
    // adds a listener while we're
    // calling listeners:
    synchronized(this) {
      lv = (Vector)actionListeners.clone();
    }
    // Call all the listener methods:
    for(int i = 0; i < lv.size(); i++) {
      ActionListener al =
        (ActionListener)lv.elementAt(i);
      al.actionPerformed(a);
    }
  }
  class ML extends MouseAdapter {
    public void mousePressed(MouseEvent e) {
      Graphics g = getGraphics();
      g.setColor(tColor);
      g.setFont(
        new Font(
          "TimesRoman", Font.BOLD, fontSize));
      int width =
        g.getFontMetrics().stringWidth(text);
      g.drawString(text,
        (getSize().width - width) /2,
        getSize().height/2);
      g.dispose();
      notifyListeners();
    }
  }
  class MM extends MouseMotionAdapter {
    public void mouseMoved(MouseEvent e) {
      xm = e.getX();
      ym = e.getY();
      repaint();
    }
  }
  // Testing the BangBean2:
  public static void main(String[] args) {
    BangBean2 bb = new BangBean2();
    bb.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e){
        System.out.println("ActionEvent" + e);
      }
    });
    bb.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e){
        System.out.println("BangBean2 action");
      }
    });
    bb.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e){
        System.out.println("More action");
      }
    });
    Frame aFrame = new Frame("BangBean2 Test");
    aFrame.addWindowListener(new WindowAdapter(){
      public void windowClosing(WindowEvent e) {
        System.exit(0);
      }
    });
    aFrame.add(bb, BorderLayout.CENTER);
    aFrame.setSize(300,300);
    aFrame.setVisible(true);
  }
} ///:~
```

很容易就可以為方法添加`synchronized`。但注意在`addActionListener()`和`removeActionListener()`中，現在添加了`ActionListener`，並從一個`Vector`中移去，所以能夠根據自己願望使用任意多個。

我們注意到，`notifyListeners()`方法並未設為“同步”。可從多個執行緒中發出對這個方法的呼叫。另外，在對`notifyListeners()`呼叫的中途，也可能發出對`addActionListener()`和`removeActionListener()`的呼叫。這顯然會造成問題，因為它否定了`Vector actionListeners`。為緩解這個問題，我們在一個`synchronized`從句中“克隆”了`Vector`，並對克隆進行了否定。這樣便可在不影響`notifyListeners()`的前提下，對`Vector`進行操縱。

`paint()`方法也沒有設為“同步”。與單純地添加自己的方法相比，決定是否對重載的方法進行同步要困難得多。在這個例子中，無論`paint()`是否“同步”，它似乎都能正常地工作。但必須考慮的問題包括：

(1) 方法會在物件內部修改“關鍵”變量的狀態嗎？為判斷一個變量是否“關鍵”，必須知道它是否會被程序中的其他執行緒讀取或設置（就目前的情況看，讀取或設置幾乎肯定是通過“同步”方法進行的，所以可以只對它們進行檢查）。對`paint()`的情況來說，不會發生任何修改。

(2) 方法要以這些“關鍵”變量的狀態為基礎嗎？如果一個“同步”方法修改了一個變量，而我們的方法要用到這個變量，那麼一般都願意把自己的方法也設為“同步”。基於這一前提，大家可觀察到`cSize`由“同步”方法進行了修改，所以`paint()`應當是“同步”的。但在這裡，我們可以問：“假如`cSize`在`paint()`執行期間發生了變化，會發生的最糟糕的事情是什麼呢？”如果發現情況不算太壞，而且僅僅是暫時的效果，那麼最好保持`paint()`的“不同步”狀態，以避免同步方法呼叫帶來的額外開銷。

(3) 要留意的第三條線索是`paint()`基類版本是否“同步”，在這裡它不是同步的。這並不是一個非常嚴格的參數，僅僅是一條“線索”。比如在目前的情況下，通過同步方法（好`cSize`）改變的一個字段已組合到`paint()`公式裡，而且可能已改變了情況。但請注意，`synchronized`不能繼承——也就是說，假如一個方法在基類中是“同步”的，那麼在派生類重載版本中，它不會自動進入“同步”狀態。

`TestBangBean2`中的測試程式碼已在前一章的基礎上進行了修改，已在其中加入了額外的“聽眾”，從而演示了`BangBean2`的多轉換能力。


# 14.3 堵塞


一個執行緒可以有四種狀態：

(1) 新（New）：執行緒物件已經創建，但尚未啟動，所以不可運行。

(2) 可運行（Runnable）：意味著一旦時間分片機制有空閒的CPU週期提供給一個執行緒，那個執行緒便可立即開始運行。因此，執行緒可能在、也可能不在運行當中，但一旦條件許可，沒有什麼能阻止它的運行——它既沒有“死”掉，也未被“堵塞”。

(3) 死（Dead）：從自己的`run()`方法中返回後，一個執行緒便已“死”掉。亦可呼叫`stop()`令其死掉，但會產生一個異常——屬於`Error`的一個子類（也就是說，我們通常不捕獲它）。記住一個異常的“拋”出應當是一個特殊事件，而不是正常程序運行的一部分。所以不建議你使用`stop()`（在Java 1.2則是堅決反對）。另外還有一個`destroy()`方法（它永遠不會實作），應該儘可能地避免呼叫它，因為它非常武斷，根本不會解除物件的鎖定。

(4) 堵塞（Blocked）：執行緒可以運行，但有某種東西阻礙了它。若執行緒處於堵塞狀態，調度機制可以簡單地跳過它，不給它分配任何CPU時間。除非執行緒再次進入“可運行”狀態，否則不會採取任何操作。

## 14.3.1 為何會堵塞

堵塞狀態是前述四種狀態中最有趣的，值得我們作進一步的探討。執行緒被堵塞可能是由下述五方面的原因造成的：

(1) 呼叫`sleep(毫秒數)`，使執行緒進入“睡眠”狀態。在規定的時間內，這個執行緒是不會運行的。

(2) 用`suspend()`暫停了執行緒的執行。除非執行緒收到`resume()`訊息，否則不會返回“可運行”狀態。

(3) 用`wait()`暫停了執行緒的執行。除非執行緒收到`nofify()`或者`notifyAll()`訊息，否則不會變成“可運行”（是的，這看起來同原因2非常相象，但有一個明顯的區別是我們馬上要揭示的）。

(4) 執行緒正在等候一些IO（輸入輸出）操作完成。

(5) 執行緒試圖呼叫另一個物件的“同步”方法，但那個物件處於鎖定狀態，暫時無法使用。

亦可呼叫`yield()`（`Thread`類的一個方法）自動放棄CPU，以便其他執行緒能夠運行。然而，假如調度機制覺得我們的執行緒已擁有足夠的時間，並跳轉到另一個執行緒，就會發生同樣的事情。也就是說，沒有什麼能防止調度機制重新啟動我們的執行緒。執行緒被堵塞後，便有一些原因造成它不能繼續運行。

下面這個例子展示了進入堵塞狀態的全部五種途徑。它們全都存在於名為`Blocking.java`的一個文件中，但在這兒採用散落的片斷進行解釋（大家可注意到片斷前後的`Continued`以及`Continuing`標誌。利用第17章介紹的工具，可將這些片斷連結到一起）。首先讓我們看看基本的框架：

```
//: Blocking.java
// Demonstrates the various ways a thread
// can be blocked.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
import java.io.*;

//////////// The basic framework ///////////
class Blockable extends Thread {
  private Peeker peeker;
  protected TextField state = new TextField(40);
  protected int i;
  public Blockable(Container c) {
    c.add(state);
    peeker = new Peeker(this, c);
  }
  public synchronized int read() { return i; }
  protected synchronized void update() {
    state.setText(getClass().getName()
      + " state: i = " + i);
  }
  public void stopPeeker() {
    // peeker.stop(); Deprecated in Java 1.2
    peeker.terminate(); // The preferred approach
  }
}

class Peeker extends Thread {
  private Blockable b;
  private int session;
  private TextField status = new TextField(40);
  private boolean stop = false;
  public Peeker(Blockable b, Container c) {
    c.add(status);
    this.b = b;
    start();
  }
  public void terminate() { stop = true; }
  public void run() {
    while (!stop) {
      status.setText(b.getClass().getName()
        + " Peeker " + (++session)
        + "; value = " + b.read());
       try {
        sleep(100);
      } catch (InterruptedException e){}
    }
  }
} ///:Continued
```

`Blockable`類打算成為本例所有類的一個基類。一個`Blockable`物件包含了一個名為`state`的`TextField`（文本字段），用於顯示出物件有關的信息。用於顯示這些信息的方法叫作`update()`。我們發現它用`getClass.getName()`來產生類名，而不是僅僅把它打印出來；這是由於`update(0)`不知道自己為其呼叫的那個類的準確名字，因為那個類是從`Blockable`派生出來的。

在`Blockable`中，變動指示符是一個`int i`；派生類的`run()`方法會為其自增。

針對每個`Bloackable`物件，都會啟動`Peeker`類的一個執行緒。`Peeker`的任務是呼叫`read()`方法，檢查與自己關聯的`Blockable`物件，看看i是否發生了變化，最後用它的`status`文本字段報告檢查結果。注意`read()`和`update()`都是同步的，要求物件的鎖定能自由解除，這一點非常重要。

(1) 睡眠


這個程序的第一項測試是用`sleep()`作出的：

```
///:Continuing
///////////// Blocking via sleep() ///////////
class Sleeper1 extends Blockable {
  public Sleeper1(Container c) { super(c); }
  public synchronized void run() {
    while(true) {
      i++;
      update();
       try {
        sleep(1000);
      } catch (InterruptedException e){}
    }
  }
}

class Sleeper2 extends Blockable {
  public Sleeper2(Container c) { super(c); }
  public void run() {
    while(true) {
      change();
       try {
        sleep(1000);
      } catch (InterruptedException e){}
    }
  }
  public synchronized void change() {
      i++;
      update();
  }
} ///:Continued
```

在`Sleeper1`中，整個`run()`方法都是同步的。我們可看到與這個物件關聯在一起的`Peeker`可以正常運行，直到我們啟動執行緒為止，隨後`Peeker`便會完全停止。這正是“堵塞”的一種形式：因為`Sleeper1.run()`是同步的，而且一旦執行緒啟動，它就肯定在`run()`內部，方法永遠不會放棄物件鎖定，造成`Peeker`執行緒的堵塞。

`Sleeper2`通過設置不同步的運行，提供了一種解決方法。只有`change()`方法才是同步的，所以儘管`run()`位於`sleep()`內部，`Peeker`仍然能訪問自己需要的同步方法——`read()`。在這裡，我們可看到在啟動了`Sleeper2`執行緒以後，`Peeker`會持續運行下去。

(2) 暫停和恢復

這個例子接下來的一部分引入了“掛起”或者“暫停”（`Suspend`）的概述。`Thread`類提供了一個名為`suspend()`的方法，可臨時中止執行緒；以及一個名為`resume()`的方法，用於從暫停處開始恢復執行緒的執行。顯然，我們可以推斷出`resume()`是由暫停執行緒外部的某個執行緒呼叫的。在這種情況下，需要用到一個名為`Resumer`（恢復器）的獨立類。演示暫停／恢復過程的每個類都有一個相關的恢復器。如下所示：

```
///:Continuing
/////////// Blocking via suspend() ///////////
class SuspendResume extends Blockable {
  public SuspendResume(Container c) {
    super(c);    
    new Resumer(this);
  }
}

class SuspendResume1 extends SuspendResume {
  public SuspendResume1(Container c) { super(c);}
  public synchronized void run() {
    while(true) {
      i++;
      update();
      suspend(); // Deprecated in Java 1.2
    }
  }
}

class SuspendResume2 extends SuspendResume {
  public SuspendResume2(Container c) { super(c);}
  public void run() {
    while(true) {
      change();
      suspend(); // Deprecated in Java 1.2
    }
  }
  public synchronized void change() {
      i++;
      update();
  }
}

class Resumer extends Thread {
  private SuspendResume sr;
  public Resumer(SuspendResume sr) {
    this.sr = sr;
    start();
  }
  public void run() {
    while(true) {
       try {
        sleep(1000);
      } catch (InterruptedException e){}
      sr.resume(); // Deprecated in Java 1.2
    }
  }
} ///:Continued
```

`SuspendResume1`也提供了一個同步的`run()`方法。同樣地，當我們啟動這個執行緒以後，就會發現與它關聯的`Peeker`進入“堵塞”狀態，等候物件鎖被釋放，但那永遠不會發生。和往常一樣，這個問題在`SuspendResume2`裡得到了解決，它並不同步整個`run()`方法，而是採用了一個單獨的同步`change()`方法。

對於Java 1.2，大家應注意`suspend()`和`resume()`已獲得強烈反對，因為`suspend()`包含了物件鎖，所以極易出現“死鎖”現象。換言之，很容易就會看到許多被鎖住的物件在傻乎乎地等待對方。這會造成整個應用程序的“凝固”。儘管在一些老程序中還能看到它們的蹤跡，但在你寫自己的程序時，無論如何都應避免。本章稍後就會講述正確的方法是什麼。

(3) 等待和通知

通過前兩個例子的實踐，我們知道無論`sleep()`還是`suspend()`都不會在自己被呼叫的時候解除鎖定。需要用到物件鎖時，請務必注意這個問題。在另一方面，`wait()`方法在被呼叫時卻會解除鎖定，這意味著可在執行`wait()`期間呼叫執行緒物件中的其他同步方法。但在接著的兩個類中，我們看到`run()`方法都是“同步”的。在`wait()`期間，`Peeker`仍然擁有對同步方法的完全訪問權限。這是由於`wait()`在掛起內部呼叫的方法時，會解除物件的鎖定。

我們也可以看到`wait()`的兩種形式。第一種形式採用一個以毫秒為單位的參數，它具有與`sleep()`中相同的含義：暫停這一段規定時間。區別在於在`wait()`中，物件鎖已被解除，而且能夠自由地退出`wait()`，因為一個`notify()`可強行使時間流逝。

第二種形式不採用任何參數，這意味著`wait()`會持續執行，直到`notify()`介入為止。而且在一段時間以後，不會自行中止。

`wait()`和`notify()`比較特別的一個地方是這兩個方法都屬於基類`Object`的一部分，不像`sleep()`，`suspend()`以及`resume()`那樣屬於`Thread`的一部分。儘管這表面看有點兒奇怪——居然讓專門進行執行緒處理的東西成為通用基類的一部分——但仔細想想又會釋然，因為它們操縱的物件鎖也屬於每個物件的一部分。因此，我們可將一個`wait()`置入任何同步方法內部，無論在那個類裡是否準備進行涉及執行緒的處理。事實上，我們能呼叫`wait()`的唯一地方是在一個同步的方法或程式碼塊內部。若在一個不同步的方法內呼叫`wait()`或者`notify()`，儘管程序仍然會編譯，但在運行它的時候，就會得到一個`IllegalMonitorStateException`（非法監視器狀態異常），而且會出現多少有點莫名其妙的一則訊息：`current thread not owner`（當前執行緒不是所有人”。注意`sleep()`，`suspend()`以及`resume()`都能在不同步的方法內呼叫，因為它們不需要對鎖定進行操作。

只能為自己的鎖定呼叫`wait()`和`notify()`。同樣地，仍然可以編譯那些試圖使用錯誤鎖定的程式碼，但和往常一樣會產生同樣的`IllegalMonitorStateException`異常。我們沒辦法用其他人的物件鎖來愚弄系統，但可要求另一個物件執行相應的操作，對它自己的鎖進行操作。所以一種做法是創建一個同步方法，令其為自己的物件呼叫`notify()`。但在`Notifier`中，我們會看到一個同步方法內部的`notify()`：

```
synchronized(wn2) {
  wn2.notify();
}
```

其中，`wn2`是類型為`WaitNotify2`的物件。儘管並不屬於`WaitNotify2`的一部分，這個方法仍然獲得了`wn2`物件的鎖定。在這個時候，它為`wn2`呼叫`notify()`是合法的，不會得到`IllegalMonitorStateException`異常。

```
///:Continuing
/////////// Blocking via wait() ///////////
class WaitNotify1 extends Blockable {
  public WaitNotify1(Container c) { super(c); }
  public synchronized void run() {
    while(true) {
      i++;
      update();
       try {
        wait(1000);
      } catch (InterruptedException e){}
    }
  }
}

class WaitNotify2 extends Blockable {
  public WaitNotify2(Container c) {
    super(c);
    new Notifier(this);
  }
  public synchronized void run() {
    while(true) {
      i++;
      update();
       try {
        wait();
      } catch (InterruptedException e){}
    }
  }
}

class Notifier extends Thread {
  private WaitNotify2 wn2;
  public Notifier(WaitNotify2 wn2) {
    this.wn2 = wn2;
    start();
  }
  public void run() {
    while(true) {
       try {
        sleep(2000);
      } catch (InterruptedException e){}
      synchronized(wn2) {
        wn2.notify();
      }
    }
  }
} ///:Continued
```

若必須等候其他某些條件（從執行緒外部加以控制）發生變化，同時又不想在執行緒內一直傻乎乎地等下去，一般就需要用到`wait()`。`wait()`允許我們將執行緒置入“睡眠”狀態，同時又“積極”地等待條件發生改變。而且只有在一個`notify()`或`notifyAll()`發生變化的時候，執行緒才會被喚醒，並檢查條件是否有變。因此，我們認為它提供了在執行緒間進行同步的一種手段。

(4) IO堵塞

若一個數據流必須等候一些IO活動，便會自動進入“堵塞”狀態。在本例下面列出的部分中，有兩個類協同通用的`Reader`以及`Writer`物件工作（使用Java 1.1的流）。但在測試模型中，會設置一個管道化的數據流，使兩個執行緒相互間能安全地傳遞數據（這正是使用管道流的目的）。

`Sender`將數據置入`Writer`，並“睡眠”隨機長短的時間。然而，`Receiver`本身並沒有包括`sleep()`，`suspend()`或者`wait()`方法。但在執行`read()`的時候，如果沒有數據存在，它會自動進入“堵塞”狀態。如下所示：

```
///:Continuing
class Sender extends Blockable { // send
  private Writer out;
  public Sender(Container c, Writer out) {
    super(c);
    this.out = out;
  }
  public void run() {
    while(true) {
      for(char c = 'A'; c <= 'z'; c++) {
         try {
          i++;
          out.write(c);
          state.setText("Sender sent: "
            + (char)c);
          sleep((int)(3000 * Math.random()));
        } catch (InterruptedException e){}
          catch (IOException e) {}
      }
    }
  }
}

class Receiver extends Blockable {
  private Reader in;
  public Receiver(Container c, Reader in) {
    super(c);
    this.in = in;
  }
  public void run() {
    try {
      while(true) {
        i++; // Show peeker it's alive
        // Blocks until characters are there:
        state.setText("Receiver read: "
          + (char)in.read());
      }
    } catch(IOException e) { e.printStackTrace();}
  }
} ///:Continued
```

這兩個類也將信息送入自己的`state`字段，並修改`i`值，使`Peeker`知道執行緒仍在運行。

(5) 測試

令人驚訝的是，主要的程序片（Applet）類非常簡單，這是大多數工作都已置入`Blockable`框架的緣故。大概地說，我們創建了一個由`Blockable`物件構成的數組。而且由於每個物件都是一個執行緒，所以在按下`"start"`按鈕後，它們會採取自己的行動。還有另一個按鈕和`actionPerformed()`從句，用於中止所有`Peeker`物件。由於Java 1.2“反對”使用`Thread`的`stop()`方法，所以可考慮採用這種折衷形式的中止方式。

為了在`Sender`和`Receiver`之間建立一個連接，我們創建了一個`PipedWriter`和一個`PipedReader`。注意`PipedReader in`必須通過一個建構子參數同`PipedWriterout`連接起來。在那以後，我們在`out`內放進去的所有東西都可從`in`中提取出來——似乎那些東西是通過一個“管道”傳輸過去的。隨後將`in`和`out`物件分別傳遞給`Receiver`和`Sender`建構子；後者將它們當作任意類型的`Reader`和`Writer`看待（也就是說，它們被“上溯”轉換了）。

`Blockable`引用`b`的數組在定義之初並未得到初始化，因為管道化的數據流是不可在定義前設置好的（對`try`塊的需要將成為障礙）：

```
///:Continuing
/////////// Testing Everything ///////////
public class Blocking extends Applet {
  private Button
    start = new Button("Start"),
    stopPeekers = new Button("Stop Peekers");
  private boolean started = false;
  private Blockable[] b;
  private PipedWriter out;
  private PipedReader in;
  public void init() {
     out = new PipedWriter();
    try {
      in = new PipedReader(out);
    } catch(IOException e) {}
    b = new Blockable[] {
      new Sleeper1(this),
      new Sleeper2(this),
      new SuspendResume1(this),
      new SuspendResume2(this),
      new WaitNotify1(this),
      new WaitNotify2(this),
      new Sender(this, out),
      new Receiver(this, in)
    };
    start.addActionListener(new StartL());
    add(start);
    stopPeekers.addActionListener(
      new StopPeekersL());
    add(stopPeekers);
  }
  class StartL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      if(!started) {
        started = true;
        for(int i = 0; i < b.length; i++)
          b[i].start();
      }
    }
  }
  class StopPeekersL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      // Demonstration of the preferred
      // alternative to Thread.stop():
      for(int i = 0; i < b.length; i++)
        b[i].stopPeeker();
    }
  }
  public static void main(String[] args) {
    Blocking applet = new Blocking();
    Frame aFrame = new Frame("Blocking");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(350,550);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

在`init()`中，注意循環會遍歷整個數組，併為頁添加`state`和`peeker.status`文本字段。

首次創建好`Blockable`執行緒以後，每個這樣的執行緒都會自動創建並啟動自己的`Peeker`。所以我們會看到各個`Peeker`都在`Blockable`執行緒啟動之前運行起來。這一點非常重要，因為在`Blockable`執行緒啟動的時候，部分`Peeker`會被堵塞，並停止運行。弄懂這一點，將有助於我們加深對“堵塞”這一概念的認識。

## 14.3.2 死鎖

由於執行緒可能進入堵塞狀態，而且由於物件可能擁有“同步”方法——除非同步鎖定被解除，否則執行緒不能訪問那個物件——所以一個執行緒完全可能等候另一個物件，而另一個物件又在等候下一個物件，以此類推。這個“等候”鏈最可怕的情形就是進入封閉狀態——最後那個物件等候的是第一個物件！此時，所有執行緒都會陷入無休止的相互等待狀態，大家都動彈不得。我們將這種情況稱為“死鎖”。儘管這種情況並非經常出現，但一旦碰到，程序的調試將變得異常艱難。

就語言本身來說，尚未直接提供防止死鎖的幫助措施，需要我們通過謹慎的設計來避免。如果有誰需要調試一個死鎖的程序，他是沒有任何竅門可用的。

(1) Java 1.2對`stop()`，`suspend()`，`resume()`以及`destroy()`的反對

為減少出現死鎖的可能，Java 1.2作出的一項貢獻是“反對”使用`Thread`的`stop()`，`suspend()`，`resume()`以及`destroy()`方法。

之所以反對使用`stop()`，是因為它不安全。它會解除由執行緒獲取的所有鎖定，而且如果物件處於一種不連貫狀態（“被析構”），那麼其他執行緒能在那種狀態下檢查和修改它們。結果便造成了一種微妙的局面，我們很難檢查出真正的問題所在。所以應儘量避免使用`stop()`，應該採用`Blocking.java`那樣的方法，用一個標誌告訴執行緒什麼時候通過退出自己的`run()`方法來中止自己的執行。

如果一個執行緒被堵塞，比如在它等候輸入的時候，那麼一般都不能象在`Blocking.java`中那樣輪詢一個標誌。但在這些情況下，我們仍然不該使用`stop()`，而應換用由`Thread`提供的`interrupt()`方法，以便中止並退出堵塞的程式碼。

```
//: Interrupt.java
// The alternative approach to using stop()
// when a thread is blocked
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

class Blocked extends Thread {
  public synchronized void run() {
    try {
      wait(); // Blocks
    } catch(InterruptedException e) {
      System.out.println("InterruptedException");
    }
    System.out.println("Exiting run()");
  }
}

public class Interrupt extends Applet {
  private Button
    interrupt = new Button("Interrupt");
  private Blocked blocked = new Blocked();
  public void init() {
    add(interrupt);
    interrupt.addActionListener(
      new ActionListener() {
        public
        void actionPerformed(ActionEvent e) {
          System.out.println("Button pressed");
          if(blocked == null) return;
          Thread remove = blocked;
          blocked = null; // to release it
          remove.interrupt();
        }
      });
    blocked.start();
  }
  public static void main(String[] args) {
    Interrupt applet = new Interrupt();
    Frame aFrame = new Frame("Interrupt");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(200,100);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

`Blocked.run()`內部的`wait()`會產生堵塞的執行緒。當我們按下按鈕以後，`blocked`（堵塞）的引用就會設為`null`，使垃圾收集器能夠將其清除，然後呼叫物件的`interrupt()`方法。如果是首次按下按鈕，我們會看到執行緒正常退出。但在沒有可供“殺死”的執行緒以後，看到的便只是按鈕被按下而已。

`suspend()`和`resume()`方法天生容易發生死鎖。呼叫`suspend()`的時候，目標執行緒會停下來，但卻仍然持有在這之前獲得的鎖定。此時，其他任何執行緒都不能訪問鎖定的資源，除非被“掛起”的執行緒恢復運行。對任何執行緒來說，如果它們想恢復目標執行緒，同時又試圖使用任何一個鎖定的資源，就會造成令人難堪的死鎖。所以我們不應該使用`suspend()`和`resume()`，而應在自己的`Thread`類中置入一個標誌，指出執行緒應該活動還是掛起。若標誌指出執行緒應該掛起，便用`wait()`命其進入等待狀態。若標誌指出執行緒應當恢復，則用一個`notify()`重新啟動執行緒。我們可以修改前面的`Counter2.java`來實際體驗一番。儘管兩個版本的效果是差不多的，但大家會注意到程式碼的組織結構發生了很大的變化——為所有“聽眾”都使用了匿名的內部類，而且`Thread`是一個內部類。這使得程序的編寫稍微方便一些，因為它取消了`Counter2.java`中一些額外的記錄工作。

```
//: Suspend.java
// The alternative approach to using suspend()
// and resume(), which have been deprecated
// in Java 1.2.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

public class Suspend extends Applet {
  private TextField t = new TextField(10);
  private Button
    suspend = new Button("Suspend"),
    resume = new Button("Resume");
  class Suspendable extends Thread {
    private int count = 0;
    private boolean suspended = false;
    public Suspendable() { start(); }
    public void fauxSuspend() {
      suspended = true;
    }
    public synchronized void fauxResume() {
      suspended = false;
      notify();
    }
    public void run() {
      while (true) {
        try {
          sleep(100);
          synchronized(this) {
            while(suspended)
              wait();
          }
        } catch (InterruptedException e){}
        t.setText(Integer.toString(count++));
      }
    }
  }
  private Suspendable ss = new Suspendable();
  public void init() {
    add(t);
    suspend.addActionListener(
      new ActionListener() {
        public
        void actionPerformed(ActionEvent e) {
          ss.fauxSuspend();
        }
      });
    add(suspend);
    resume.addActionListener(
      new ActionListener() {
        public
        void actionPerformed(ActionEvent e) {
          ss.fauxResume();
        }
      });
    add(resume);
  }
  public static void main(String[] args) {
    Suspend applet = new Suspend();
    Frame aFrame = new Frame("Suspend");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e){
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(300,100);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

`Suspendable`中的`suspended`（已掛起）標誌用於開關“掛起”或者“暫停”狀態。為掛起一個執行緒，只需呼叫`fauxSuspend(`)將標誌設為`true`（真）即可。對標誌狀態的偵測是在`run()`內進行的。就象本章早些時候提到的那樣，`wait()`必須設為“同步”（`synchronized`），使其能夠使用物件鎖。在`fauxResume()`中，`suspended`標誌被設為`false`（假），並呼叫`notify()`——由於這會在一個“同步”從句中喚醒`wait()`，所以`fauxResume()`方法也必須同步，使其能在呼叫`notify()`之前取得物件鎖（這樣一來，物件鎖可由要喚醍的那個`wait()`使用）。如果遵照本程序展示的樣式，可以避免使用`wait()`和`notify()`。

`Thread`的`destroy()`方法根本沒有實作；它類似一個根本不能恢復的`suspend()`，所以會發生與`suspend()`一樣的死鎖問題。然而，這一方法沒有得到明確的“反對”，也許會在Java以後的版本（1.2版以後）實作，用於一些可以承受死鎖危險的特殊場合。

大家可能會奇怪當初為什麼要實作這些現在又被“反對”的方法。之所以會出現這種情況，大概是由於Sun公司主要讓技術人員來決定對語言的改動，而不是那些市場銷售人員。通常，技術人員比搞銷售的更能理解語言的實質。當初犯下了錯誤以後，也能較為理智地正視它們。這意味著Java能夠繼續進步，即便這使Java程序員多少感到有些不便。就我自己來說，寧願面對這些不便之處，也不願看到語言停滯不前。


# 14.4 優先級


執行緒的優先級（Priority）告訴調試程序該執行緒的重要程度有多大。如果有大量執行緒都被堵塞，都在等候運行，調試程序會首先運行具有最高優先級的那個執行緒。然而，這並不表示優先級較低的執行緒不會運行（換言之，不會因為存在優先級而導致死鎖）。若執行緒的優先級較低，只不過表示它被準許運行的機會小一些而已。

可用`getPriority()`方法讀取一個執行緒的優先級，並用`setPriority()`改變它。在下面這個程序片中，大家會發現計數器的計數速度慢了下來，因為它們關聯的執行緒分配了較低的優先級：

```
//: Counter5.java
// Adjusting the priorities of threads
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

class Ticker2 extends Thread {
  private Button
    b = new Button("Toggle"),
    incPriority = new Button("up"),
    decPriority = new Button("down");
  private TextField
    t = new TextField(10),
    pr = new TextField(3); // Display priority
  private int count = 0;
  private boolean runFlag = true;
  public Ticker2(Container c) {
    b.addActionListener(new ToggleL());
    incPriority.addActionListener(new UpL());
    decPriority.addActionListener(new DownL());
    Panel p = new Panel();
    p.add(t);
    p.add(pr);
    p.add(b);
    p.add(incPriority);
    p.add(decPriority);
    c.add(p);
  }
  class ToggleL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      runFlag = !runFlag;
    }
  }
  class UpL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      int newPriority = getPriority() + 1;
      if(newPriority > Thread.MAX_PRIORITY)
        newPriority = Thread.MAX_PRIORITY;
      setPriority(newPriority);
    }
  }
  class DownL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      int newPriority = getPriority() - 1;
      if(newPriority < Thread.MIN_PRIORITY)
        newPriority = Thread.MIN_PRIORITY;
      setPriority(newPriority);
    }
  }
  public void run() {
    while (true) {
      if(runFlag) {
        t.setText(Integer.toString(count++));
        pr.setText(
          Integer.toString(getPriority()));
      }
      yield();
    }
  }
}

public class Counter5 extends Applet {
  private Button
    start = new Button("Start"),
    upMax = new Button("Inc Max Priority"),
    downMax = new Button("Dec Max Priority");
  private boolean started = false;
  private static final int SIZE = 10;
  private Ticker2[] s = new Ticker2[SIZE];
  private TextField mp = new TextField(3);
  public void init() {
    for(int i = 0; i < s.length; i++)
      s[i] = new Ticker2(this);
    add(new Label("MAX_PRIORITY = "
      + Thread.MAX_PRIORITY));
    add(new Label("MIN_PRIORITY = "
      + Thread.MIN_PRIORITY));
    add(new Label("Group Max Priority = "));
    add(mp);
    add(start);
    add(upMax); add(downMax);
    start.addActionListener(new StartL());
    upMax.addActionListener(new UpMaxL());
    downMax.addActionListener(new DownMaxL());
    showMaxPriority();
    // Recursively display parent thread groups:
    ThreadGroup parent =
      s[0].getThreadGroup().getParent();
    while(parent != null) {
      add(new Label(
        "Parent threadgroup max priority = "
        + parent.getMaxPriority()));
      parent = parent.getParent();
    }
  }
  public void showMaxPriority() {
    mp.setText(Integer.toString(
      s[0].getThreadGroup().getMaxPriority()));
  }
  class StartL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      if(!started) {
        started = true;
        for(int i = 0; i < s.length; i++)
          s[i].start();
      }
    }
  }
  class UpMaxL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      int maxp =
        s[0].getThreadGroup().getMaxPriority();
      if(++maxp > Thread.MAX_PRIORITY)
        maxp = Thread.MAX_PRIORITY;
      s[0].getThreadGroup().setMaxPriority(maxp);
      showMaxPriority();
    }
  }
  class DownMaxL implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      int maxp =
        s[0].getThreadGroup().getMaxPriority();
      if(--maxp < Thread.MIN_PRIORITY)
        maxp = Thread.MIN_PRIORITY;
      s[0].getThreadGroup().setMaxPriority(maxp);
      showMaxPriority();
    }
  }
  public static void main(String[] args) {
    Counter5 applet = new Counter5();
    Frame aFrame = new Frame("Counter5");
    aFrame.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
    aFrame.add(applet, BorderLayout.CENTER);
    aFrame.setSize(300, 600);
    applet.init();
    applet.start();
    aFrame.setVisible(true);
  }
} ///:~
```

`Ticker`採用本章前面構造好的形式，但有一個額外的`TextField`（文本字段），用於顯示執行緒的優先級；以及兩個額外的按鈕，用於人為提高及降低優先級。

也要注意`yield()`的用法，它將控制權自動返回給調試程序（機制）。若不進行這樣的處理，多執行緒機制仍會工作，但我們會發現它的運行速度慢了下來（試試刪去對`yield()`的呼叫）。亦可呼叫`sleep()`，但假若那樣做，計數頻率就會改由`sleep()`的持續時間控制，而不是優先級。

`Counter5`中的`init()`創建了由10個`Ticker2`構成的一個數組；它們的按鈕以及輸入字段（文本字段）由`Ticker2`建構子置入窗體。`Counter5`增加了新的按鈕，用於啟動一切，以及用於提高和降低執行緒組的最大優先級。除此以外，還有一些標籤用於顯示一個執行緒可以採用的最大及最小優先級；以及一個特殊的文本字段，用於顯示執行緒組的最大優先級（在下一節裡，我們將全面討論執行緒組的問題）。最後，父執行緒組的優先級也作為標籤顯示出來。

按下`up`（上）或`down`（下）按鈕的時候，會先取得`Ticker2`當前的優先級，然後相應地提高或者降低。

運行該程序時，我們可注意到幾件事情。首先，執行緒組的默認優先級是5。即使在啟動執行緒之前（或者在創建執行緒之前，這要求對程式碼進行適當的修改）將最大優先級降到5以下，每個執行緒都會有一個5的默認優先級。

最簡單的測試是獲取一個計數器，將它的優先級降低至1，此時應觀察到它的計數頻率顯著放慢。現在試著再次提高優先級，可以升高回執行緒組的優先級，但不能再高了。現在將執行緒組的優先級降低兩次。執行緒的優先級不會改變，但假若試圖提高或者降低它，就會發現這個優先級自動變成執行緒組的優先級。此外，新執行緒仍然具有一個默認優先級，即使它比組的優先級還要高（換句話說，不要指望利用組優先級來防止新執行緒擁有比現有的更高的優先級）。

最後，試著提高組的最大優先級。可以發現，這樣做是沒有效果的。我們只能減少執行緒組的最大優先級，而不能增大它。

## 14.4.1 執行緒組

所有執行緒都隸屬於一個執行緒組。那可以是一個默認執行緒組，亦可是一個創建執行緒時明確指定的組。在創建之初，執行緒被限制到一個組裡，而且不能改變到一個不同的組。每個應用都至少有一個執行緒從屬於系統執行緒組。若創建多個執行緒而不指定一個組，它們就會自動歸屬於系統執行緒組。

執行緒組也必須從屬於其他執行緒組。必須在建構子裡指定新執行緒組從屬於哪個執行緒組。若在創建一個執行緒組的時候沒有指定它的歸屬，則同樣會自動成為系統執行緒組的一名屬下。因此，一個應用程序中的所有執行緒組最終都會將系統執行緒組作為自己的“父”。

之所以要提出“執行緒組”的概念，很難從字面上找到原因。這多少為我們討論的主題帶來了一些混亂。一般地說，我們認為是由於“安全”或者“保密”方面的理由才使用執行緒組的。根據Arnold和Gosling的說法：“執行緒組中的執行緒可以修改組內的其他執行緒，包括那些位於分層結構最深處的。一個執行緒不能修改位於自己所在組或者下屬組之外的任何執行緒”（註釋①）。然而，我們很難判斷“修改”在這兒的具體含義是什麼。下面這個例子展示了位於一個“葉子組”內的執行緒能修改它所在執行緒組樹的所有執行緒的優先級，同時還能為這個“樹”內的所有執行緒都呼叫一個方法。

```
①：《The Java Programming Language》第179頁。該書由Arnold和Jams Gosling編著，Addison-Wesley於1996年出版
//: TestAccess.java
// How threads can access other threads
// in a parent thread group

public class TestAccess {
  public static void main(String[] args) {
    ThreadGroup
      x = new ThreadGroup("x"),
      y = new ThreadGroup(x, "y"),
      z = new ThreadGroup(y, "z");
    Thread
      one = new TestThread1(x, "one"),
      two = new TestThread2(z, "two");
  }
}

class TestThread1 extends Thread {
  private int i;
  TestThread1(ThreadGroup g, String name) {
    super(g, name);
  }
  void f() {
    i++; // modify this thread
    System.out.println(getName() + " f()");
  }
}

class TestThread2 extends TestThread1 {
  TestThread2(ThreadGroup g, String name) {
    super(g, name);
    start();
  }
  public void run() {
    ThreadGroup g =
      getThreadGroup().getParent().getParent();
    g.list();
    Thread[] gAll = new Thread[g.activeCount()];
    g.enumerate(gAll);
    for(int i = 0; i < gAll.length; i++) {
      gAll[i].setPriority(Thread.MIN_PRIORITY);
      ((TestThread1)gAll[i]).f();
    }
    g.list();
  }
} ///:~

```

在`main()`中，我們創建了幾個`ThreadGroup`（執行緒組），每個都位於不同的“葉”上：`x`沒有參數，只有它的名字（一個`String`），所以會自動進入`system`（系統）執行緒組；`y`位於`x`下方，而`z`位於`y`下方。注意初始化是按照文字順序進行的，所以程式碼合法。

有兩個執行緒創建之後進入了不同的執行緒組。其中，`TestThread1`沒有一個`run()`方法，但有一個`f()`，用於通知執行緒以及打印出一些東西，以便我們知道它已被呼叫。而`TestThread2`屬於`TestThread1`的一個子類，它的`run()`非常詳盡，要做許多事情。首先，它獲得當前執行緒所在的執行緒組，然後利用`getParent()`在繼承樹中向上移動兩級（這樣做是有道理的，因為我想把`TestThread2`在分級結構中向下移動兩級）。隨後，我們呼叫方法`activeCount()`，查詢這個執行緒組以及所有子執行緒組內有多少個執行緒，從而創建由指向`Thread`的引用構成的一個數組。`enumerate()`方法將指向所有這些執行緒的引用置入數組`gAll`裡。然後在整個數組裡遍歷，為每個執行緒都呼叫`f()`方法，同時修改優先級。這樣一來，位於一個“葉子”執行緒組裡的執行緒就修改了位於父執行緒組的執行緒。

調試方法`list()`打印出與一個執行緒組有關的所有信息，把它們作為標準輸出。在我們對執行緒組的行為進行調查的時候，這樣做是相當有好處的。下面是程序的輸出：

```
java.lang.ThreadGroup[name=x,maxpri=10]
    Thread[one,5,x]
    java.lang.ThreadGroup[name=y,maxpri=10]
        java.lang.ThreadGroup[name=z,maxpri=10]
            Thread[two,5,z]
one f()
two f()
java.lang.ThreadGroup[name=x,maxpri=10]
    Thread[one,1,x]
    java.lang.ThreadGroup[name=y,maxpri=10]
        java.lang.ThreadGroup[name=z,maxpri=10]
            Thread[two,1,z]
```

`list()`不僅打印出`ThreadGroup`或者`Thread`的類名，也打印出了執行緒組的名字以及它的最高優先級。對於執行緒，則打印出它們的名字，並接上執行緒優先級以及所屬的執行緒組。注意`list()`會對執行緒和執行緒組進行縮排處理，指出它們是未縮排的執行緒組的“子”。

大家可看到`f()`是由`TestThread2`的`run()`方法呼叫的，所以很明顯，組內的所有執行緒都是相當脆弱的。然而，我們只能訪問那些從自己的`system`執行緒組樹分支出來的執行緒，而且或許這就是所謂“安全”的意思。我們不能訪問其他任何人的系統執行緒樹。

(1) 執行緒組的控制

拋開安全問題不談，執行緒組最有用的一個地方就是控制：只需用單個命令即可完成對整個執行緒組的操作。下面這個例子演示了這一點，並對執行緒組內優先級的限制進行了說明。括號內的註釋數字便於大家比較輸出結果：

```
//: ThreadGroup1.java
// How thread groups control priorities
// of the threads inside them.

public class ThreadGroup1 {
  public static void main(String[] args) {
    // Get the system thread & print its Info:
    ThreadGroup sys =
      Thread.currentThread().getThreadGroup();
    sys.list(); // (1)
    // Reduce the system thread group priority:
    sys.setMaxPriority(Thread.MAX_PRIORITY - 1);
    // Increase the main thread priority:
    Thread curr = Thread.currentThread();
    curr.setPriority(curr.getPriority() + 1);
    sys.list(); // (2)
    // Attempt to set a new group to the max:
    ThreadGroup g1 = new ThreadGroup("g1");
    g1.setMaxPriority(Thread.MAX_PRIORITY);
    // Attempt to set a new thread to the max:
    Thread t = new Thread(g1, "A");
    t.setPriority(Thread.MAX_PRIORITY);
    g1.list(); // (3)
    // Reduce g1's max priority, then attempt
    // to increase it:
    g1.setMaxPriority(Thread.MAX_PRIORITY - 2);
    g1.setMaxPriority(Thread.MAX_PRIORITY);
    g1.list(); // (4)
    // Attempt to set a new thread to the max:
    t = new Thread(g1, "B");
    t.setPriority(Thread.MAX_PRIORITY);
    g1.list(); // (5)
    // Lower the max priority below the default
    // thread priority:
    g1.setMaxPriority(Thread.MIN_PRIORITY + 2);
    // Look at a new thread's priority before
    // and after changing it:
    t = new Thread(g1, "C");
    g1.list(); // (6)
    t.setPriority(t.getPriority() -1);
    g1.list(); // (7)
    // Make g2 a child Threadgroup of g1 and
    // try to increase its priority:
    ThreadGroup g2 = new ThreadGroup(g1, "g2");
    g2.list(); // (8)
    g2.setMaxPriority(Thread.MAX_PRIORITY);
    g2.list(); // (9)
    // Add a bunch of new threads to g2:
    for (int i = 0; i < 5; i++)
      new Thread(g2, Integer.toString(i));
    // Show information about all threadgroups
    // and threads:
    sys.list(); // (10)
    System.out.println("Starting all threads:");
    Thread[] all = new Thread[sys.activeCount()];
    sys.enumerate(all);
    for(int i = 0; i < all.length; i++)
      if(!all[i].isAlive())
        all[i].start();
    // Suspends & Stops all threads in
    // this group and its subgroups:
    System.out.println("All threads started");
    sys.suspend(); // Deprecated in Java 1.2
    // Never gets here...
    System.out.println("All threads suspended");
    sys.stop(); // Deprecated in Java 1.2
    System.out.println("All threads stopped");
  }
} ///:~
```

下面的輸出結果已進行了適當的編輯，以便用一頁能夠裝下（`java.lang.`已被刪去），而且添加了適當的數字，與前面程序列表中括號裡的數字對應：

```
(1) ThreadGroup[name=system,maxpri=10]
      Thread[main,5,system]
(2) ThreadGroup[name=system,maxpri=9]
      Thread[main,6,system]
(3) ThreadGroup[name=g1,maxpri=9]
      Thread[A,9,g1]
(4) ThreadGroup[name=g1,maxpri=8]
      Thread[A,9,g1]
(5) ThreadGroup[name=g1,maxpri=8]
      Thread[A,9,g1]
      Thread[B,8,g1]
(6) ThreadGroup[name=g1,maxpri=3]
      Thread[A,9,g1]
      Thread[B,8,g1]
      Thread[C,6,g1]
(7) ThreadGroup[name=g1,maxpri=3]
      Thread[A,9,g1]
      Thread[B,8,g1]
      Thread[C,3,g1]
(8) ThreadGroup[name=g2,maxpri=3]
(9) ThreadGroup[name=g2,maxpri=3]
(10)ThreadGroup[name=system,maxpri=9]
      Thread[main,6,system]
      ThreadGroup[name=g1,maxpri=3]
        Thread[A,9,g1]
        Thread[B,8,g1]
        Thread[C,3,g1]
        ThreadGroup[name=g2,maxpri=3]
          Thread[0,6,g2]
          Thread[1,6,g2]
          Thread[2,6,g2]
          Thread[3,6,g2]
          Thread[4,6,g2]
Starting all threads:
All threads started
```

所有程序都至少有一個執行緒在運行，而且`main()`採取的第一項行動便是呼叫`Thread`的一個`static`（靜態）方法，名為`currentThread()`。從這個執行緒開始，執行緒組將被創建，而且會為結果呼叫`list()`。輸出如下：

```
(1) ThreadGroup[name=system,maxpri=10]
      Thread[main,5,system]
```

我們可以看到，主執行緒組的名字是`system`，而主執行緒的名字是`main`，而且它從屬於`system`執行緒組。

第二個練習顯示出`system`組的最高優先級可以減少，而且`main`執行緒可以增大自己的優先級：

```
(2) ThreadGroup[name=system,maxpri=9]
      Thread[main,6,system]
```

第三個練習創建一個新的執行緒組，名為`g1`；它自動從屬於`system`執行緒組，因為並沒有明確指定它的歸屬關係。我們在`g1`內部放置了一個新執行緒，名為`A`。隨後，我們試著將這個組的最大優先級設到最高的級別，並將`A`的優先級也設到最高一級。結果如下：

```
(3) ThreadGroup[name=g1,maxpri=9]
      Thread[A,9,g1]
```      

可以看出，不可能將執行緒組的最大優先級設為高於它的父執行緒組。

第四個練習將`g1`的最大優先級降低兩級，然後試著把它升至`Thread.MAX_PRIORITY`。結果如下：

```
(4) ThreadGroup[name=g1,maxpri=8]
      Thread[A,9,g1]
```

同樣可以看出，提高最大優先級的企圖是失敗的。我們只能降低一個執行緒組的最大優先級，而不能提高它。此外，注意執行緒A的優先級並未改變，而且它現在高於執行緒組的最大優先級。也就是說，執行緒組最大優先級的變化並不能對現有執行緒造成影響。

第五個練習試著將一個新執行緒設為最大優先級。如下所示：

```
(5) ThreadGroup[name=g1,maxpri=8]
      Thread[A,9,g1]
      Thread[B,8,g1]
```

因此，新執行緒不能變到比最大執行緒組優先級還要高的一級。

這個程序的默認執行緒優先級是6；若新建一個執行緒，那就是它的默認優先級，而且不會發生變化，除非對優先級進行了特別的處理。練習六將把執行緒組的最大優先級降至默認執行緒優先級以下，看看在這種情況下新建一個執行緒會發生什麼事情：

```
(6) ThreadGroup[name=g1,maxpri=3]
      Thread[A,9,g1]
      Thread[B,8,g1]
      Thread[C,6,g1]
```

儘管執行緒組現在的最大優先級是3，但仍然用默認優先級6來創建新執行緒。所以，執行緒組的最大優先級不會影響默認優先級（事實上，似乎沒有辦法可以設置新執行緒的默認優先級）。

改變了優先級後，接下來試試將其降低一級，結果如下：

```
(7) ThreadGroup[name=g1,maxpri=3]
      Thread[A,9,g1]
      Thread[B,8,g1]
      Thread[C,3,g1]
```

因此，只有在試圖改變優先級的時候，才會強迫遵守執行緒組最大優先級的限制。

我們在(8)和(9)中進行了類似的試驗。在這裡，我們創建了一個新的執行緒組，名為`g2`，將其作為`g1`的一個子組，並改變了它的最大優先級。大家可以看到，`g2`的優先級無論如何都不可能高於`g1`：

```
(8) ThreadGroup[name=g2,maxpri=3]
(9) ThreadGroup[name=g2,maxpri=3]
```

也要注意在`g2`創建的時候，它會被自動設為`g1`的執行緒組最大優先級。

經過所有這些實驗以後，整個執行緒組和執行緒系統都會被打印出來，如下所示：

```
(10)ThreadGroup[name=system,maxpri=9]
      Thread[main,6,system]
      ThreadGroup[name=g1,maxpri=3]
        Thread[A,9,g1]
        Thread[B,8,g1]
        Thread[C,3,g1]
        ThreadGroup[name=g2,maxpri=3]
          Thread[0,6,g2]
          Thread[1,6,g2]
          Thread[2,6,g2]
          Thread[3,6,g2]
          Thread[4,6,g2]
```

所以由執行緒組的規則所限，一個子組的最大優先級在任何時候都只能低於或等於它的父組的最大優先級。

本程序的最後一個部分演示了用於整組執行緒的方法。程序首先遍歷整個執行緒樹，並啟動每一個尚未啟動的執行緒。例如，`system`組隨後會被掛起（暫停），最後被中止（儘管用`suspend()`和`stop()`對整個執行緒組進行操作看起來似乎很有趣，但應注意這些方法在Java 1.2裡都是被“反對”的）。但在掛起`system`組的同時，也掛起了`main`執行緒，而且整個程序都會關閉。所以永遠不會達到讓執行緒中止的那一步。實際上，假如真的中止了`main`執行緒，它會“拋”出一個`ThreadDeath`異常，所以我們通常不這樣做。由於`ThreadGroup`是從`Object`繼承的，其中包含了`wait()`方法，所以也能呼叫`wait(秒數×1000)`，令程序暫停運行任意秒數的時間。當然，事前必須在一個同步塊裡取得物件鎖。

`ThreadGroup`類也提供了`suspend()`和`resume()`方法，所以能中止和啟動整個執行緒組和它的所有執行緒，也能中止和啟動它的子組，所有這些只需一個命令即可（再次提醒，`suspend()`和`resume()`都是Java 1.2所“反對”的）。

從表面看，執行緒組似乎有些讓人摸不著頭腦，但請注意我們很少需要直接使用它們。


# 14.5 回顧runnable


在本章早些時候，我曾建議大家在將一個程序片或主`Frame`當作`Runnable`的實作形式之前，一定要好好地想一想。若採用那種方式，就只能在自己的程序中使用其中的一個執行緒。這便限制了靈活性，一旦需要用到屬於那種類型的多個執行緒，就會遇到不必要的麻煩。

當然，如果必須從一個類繼承，而且想使類具有執行緒處理能力，則`Runnable`是一種正確的方法。本章最後一個例子對這一點進行了剖析，製作了一個`RunnableCanvas`類，用於為自己描繪不同的顏色（`Canvas`是“畫布”的意思）。這個應用被設計成從命令行獲得參數值，以決定顏色網格有多大，以及顏色發生變化之間的`sleep()`有多長。通過運用這些值，大家能體驗到執行緒一些有趣而且可能令人費解的特性：

```
//: ColorBoxes.java
// Using the Runnable interface
import java.awt.*;
import java.awt.event.*;

class CBox extends Canvas implements Runnable {
  private Thread t;
  private int pause;
  private static final Color[] colors = {
    Color.black, Color.blue, Color.cyan,
    Color.darkGray, Color.gray, Color.green,
    Color.lightGray, Color.magenta,
    Color.orange, Color.pink, Color.red,
    Color.white, Color.yellow
  };
  private Color cColor = newColor();
  private static final Color newColor() {
    return colors[
      (int)(Math.random() * colors.length)
    ];
  }
  public void paint(Graphics  g) {
    g.setColor(cColor);
    Dimension s = getSize();
    g.fillRect(0, 0, s.width, s.height);
  }
  public CBox(int pause) {
    this.pause = pause;
    t = new Thread(this);
    t.start();
  }
  public void run() {
    while(true) {
      cColor = newColor();
      repaint();
      try {
        t.sleep(pause);
      } catch(InterruptedException e) {}
    }
  }
}

public class ColorBoxes extends Frame {
  public ColorBoxes(int pause, int grid) {
    setTitle("ColorBoxes");
    setLayout(new GridLayout(grid, grid));
    for (int i = 0; i < grid * grid; i++)
      add(new CBox(pause));
    addWindowListener(new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        System.exit(0);
      }
    });
  }   
  public static void main(String[] args) {
    int pause = 50;
    int grid = 8;
    if(args.length > 0)
      pause = Integer.parseInt(args[0]);
    if(args.length > 1)
      grid = Integer.parseInt(args[1]);
    Frame f = new ColorBoxes(pause, grid);
    f.setSize(500, 400);
    f.setVisible(true);  
  }
} ///:~
```

`ColorBoxes`是一個典型的應用（程序），有一個建構子用於設置GUI。這個建構子採用`int grid`的一個參數，用它設置`GridLayout`（網格佈局），使每一維裡都有一個`grid`單元。隨後，它添加適當數量的`CBox`物件，用它們填充網格，併為每一個都傳遞`pause`值。在`main()`中，我們可看到如何對`pause`和`grid`的默認值進行修改（如果用命令行參數傳遞）。

`CBox`是進行正式工作的地方。它是從`Canvas`繼承的，並實作了`Runnable`界面，使每個`Canvas`也能是一個`Thread`。記住在實作`Runnable`的時候，並沒有實際產生一個`Thread`物件，只是一個擁有`run()`方法的類。因此，我們必須明確地創建一個`Thread`物件，並將`Runnable`物件傳遞給建構子，隨後呼叫`start()`（在建構子裡進行）。在`CBox`裡，這個執行緒的名字叫作`t`。

請留意數組`colors`，它對`Color`類中的所有顏色進行了列舉（枚舉）。它在`newColor()`中用於產生一種隨機選擇的顏色。當前的單元（格）顏色是`cColor`。

`paint()`則相當簡單——只是將顏色設為`cColor`，然後用那種顏色填充整張畫布（`Canvas`）。

在`run()`中，我們看到一個無限循環，它將`cColor`設為一種隨機顏色，然後呼叫`repaint()`把它顯示出來。隨後，對執行緒執行`sleep()`，使其“休眠”由命令行指定的時間長度。

由於這種設計模式非常靈活，而且執行緒處理同每個`Canvas`元素都緊密結合在一起，所以在理論上可以生成任意多的執行緒（但在實際應用中，這要受到JVM能夠從容對付的執行緒數量的限制）。

這個程序也為我們提供了一個有趣的評測基準，因為它揭示了不同JVM機制在速度上造成的戲劇性的差異。

## 14.5.1 過多的執行緒

有些時候，我們會發現`ColorBoxes`幾乎陷於停頓狀態。在我自己的機器上，這一情況在產生了`10×10`的網格之後發生了。為什麼會這樣呢？自然地，我們有理由懷疑AWT對它做了什麼事情。所以這裡有一個例子能夠測試那個猜測，它產生了較少的執行緒。程式碼經過了重新組織，使一個`Vector`實作了`Runnable`，而且那個`Vector`容納了數量眾多的色塊，並隨機挑選一些進行更新。隨後，我們創建大量這些`Vector`物件，數量大致取決於我們挑選的網格維數。結果便是我們得到比色塊少得多的執行緒。所以假如有一個速度的加快，我們就能立即知道，因為前例的執行緒數量太多了。如下所示：

```
//: ColorBoxes2.java
// Balancing thread use
import java.awt.*;
import java.awt.event.*;
import java.util.*;

class CBox2 extends Canvas {
  private static final Color[] colors = {
    Color.black, Color.blue, Color.cyan,
    Color.darkGray, Color.gray, Color.green,
    Color.lightGray, Color.magenta,
    Color.orange, Color.pink, Color.red,
    Color.white, Color.yellow
  };
  private Color cColor = newColor();
  private static final Color newColor() {
    return colors[
      (int)(Math.random() * colors.length)
    ];
  }
  void nextColor() {
    cColor = newColor();
    repaint();
  }
  public void paint(Graphics  g) {
    g.setColor(cColor);
    Dimension s = getSize();
    g.fillRect(0, 0, s.width, s.height);
  }
}

class CBoxVector
  extends Vector implements Runnable {
  private Thread t;
  private int pause;
  public CBoxVector(int pause) {
    this.pause = pause;
    t = new Thread(this);
  }
  public void go() { t.start(); }
  public void run() {
    while(true) {
      int i = (int)(Math.random() * size());
      ((CBox2)elementAt(i)).nextColor();
      try {
        t.sleep(pause);
      } catch(InterruptedException e) {}
    }
  }
}

public class ColorBoxes2 extends Frame {
  private CBoxVector[] v;
  public ColorBoxes2(int pause, int grid) {
    setTitle("ColorBoxes2");
    setLayout(new GridLayout(grid, grid));
    v = new CBoxVector[grid];
    for(int i = 0; i < grid; i++)
      v[i] = new CBoxVector(pause);
    for (int i = 0; i < grid * grid; i++) {
      v[i % grid].addElement(new CBox2());
      add((CBox2)v[i % grid].lastElement());
    }
    for(int i = 0; i < grid; i++)
      v[i].go();
    addWindowListener(new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        System.exit(0);
      }
    });
  }   
  public static void main(String[] args) {
    // Shorter default pause than ColorBoxes:
    int pause = 5;
    int grid = 8;
    if(args.length > 0)
      pause = Integer.parseInt(args[0]);
    if(args.length > 1)
      grid = Integer.parseInt(args[1]);
    Frame f = new ColorBoxes2(pause, grid);
    f.setSize(500, 400);
    f.setVisible(true);  
  }
} ///:~
```

在`ColorBoxes2`中，我們創建了`CBoxVector`的一個數組，並對其初始化，使其容下各個`CBoxVector`網格。每個網格都知道自己該“睡眠”多長的時間。隨後為每個`CBoxVector`都添加等量的`Cbox2`物件，而且將每個`Vector`都告訴給`go()`，用它來啟動自己的執行緒。

`CBox2`類似`CBox`——能用一種隨機選擇的顏色描繪自己。但那就是`CBox2`能夠做的全部工作。所有涉及執行緒的處理都已移至`CBoxVector`進行。

`CBoxVector`也可以擁有繼承的`Thread`，並有一個類型為`Vector`的成員物件。這樣設計的好處就是`addElement()`和`elementAt()`方法可以獲得特定的參數以及返回值類型，而不是隻能獲得常規Object（它們的名字也可以變得更短）。然而，這裡採用的設計表面上看需要較少的程式碼。除此以外，它會自動保留一個`Vector`的其他所有行為。由於`elementAt()`需要大量進行“封閉”工作，用到許多括號，所以隨著程式碼主體的擴充，最終仍有可能需要大量程式碼。

和以前一樣，在我們實作`Runnable`的時候，並沒有獲得與`Thread`配套提供的所有功能，所以必須創建一個新的`Thread`，並將自己傳遞給它的建構子，以便正式“啟動”——`start()`——一些東西。大家在`CBoxVector`建構子和`go()`裡都可以體會到這一點。`run()`方法簡單地選擇`Vector`裡的一個隨機元素編號，併為那個元素呼叫`nextColor()`，令其挑選一種新的隨機顏色。

運行這個程序時，大家會發現它確實變得更快，響應也更迅速（比如在中斷它的時候，它能更快地停下來）。而且隨著網格尺寸的壯大，它也不會經常性地陷於“停頓”狀態。因此，執行緒的處理又多了一項新的考慮因素：必須隨時檢查自己有沒有“太多的執行緒”（無論對什麼程序和運行平臺）。若執行緒太多，必須試著使用上面介紹的技術，對程序中的執行緒數量進行“平衡”。如果在一個多執行緒的程序中遇到了性能上的問題，那麼現在有許多因素需要檢查：

(1) 對`sleep`，`yield()`以及／或者`wait()`的呼叫足夠多嗎？

(2) `sleep()`的呼叫時間足夠長嗎？

(3) 運行的執行緒數是不是太多？

(4) 試過不同的平臺和JVM嗎？

象這樣的一些問題是造成多執行緒應用程序的編製成為一種“技術活”的原因之一。


# 14.6 總結


何時使用多執行緒技術，以及何時避免用它，這是我們需要掌握的重要課題。骼它的主要目的是對大量任務進行有序的管理。通過多個任務的混合使用，可以更有效地利用計算機資源，或者對用戶來說顯得更方便。資源均衡的經典問題是在IO等候期間如何利用CPU。至於用戶方面的方便性，最經典的問題就是如何在一個長時間的下載過程中監視並靈敏地反應一個“停止”（`stop`）按鈕的按下。
多執行緒的主要缺點包括：

(1) 等候使用共享資源時造成程序的運行速度變慢。

(2) 對執行緒進行管理要求的額外CPU開銷。

(3) 複雜程度無意義的加大，比如用獨立的執行緒來更新數組內每個元素的愚蠢主意。

(4) 漫長的等待、浪費精力的資源競爭以及死鎖等多執行緒症狀。

執行緒另一個優點是它們用“輕度”執行切換（100條指令的順序）取代了“重度”進程場景切換（1000條指令）。由於一個進程內的所有執行緒共享相同的內存空間，所以“輕度”場景切換隻改變程序的執行和本地變量。而在“重度”場景切換時，一個進程的改變要求必須完整地交換內存空間。

執行緒處理看來好象進入了一個全新的領域，似乎要求我們學習一種全新的程序設計語言——或者至少學習一系列新的語言概念。由於大多數微機操作系統都提供了對執行緒的支持，所以程序設計語言或者庫裡也出現了對執行緒的擴展。不管在什麼情況下，涉及執行緒的程序設計：

(1) 剛開始會讓人摸不著頭腦，要求改換我們傳統的編程思路；

(2) 其他語言對執行緒的支持看來是類似的。所以一旦掌握了執行緒的概念，在其他環境也不會有太大的困難。儘管對執行緒的支持使Java語言的複雜程度多少有些增加，但請不要責怪Java。畢竟，利用執行緒可以做許多有益的事情。

多個執行緒可能共享同一個資源（比如一個物件裡的內存），這是運用執行緒時面臨的最大的一個麻煩。必須保證多個執行緒不會同時試圖讀取和修改那個資源。這要求技巧性地運用`synchronized`（同步）關鍵字。它是一個有用的工具，但必須真正掌握它，因為假若操作不當，極易出現死鎖。

除此以外，運用執行緒時還要注意一個非常特殊的問題。由於根據Java的設計，它允許我們根據需要創建任意數量的執行緒——至少理論上如此（例如，假設為一項工程方面的有限元素分析創建數以百萬的執行緒，這對Java來說並非實際）。然而，我們一般都要控制自己創建的執行緒數量的上限。因為在某些情況下，大量執行緒會將場面變得一團糟，所以工作都會幾乎陷於停頓。臨界點並不像物件那樣可以達到幾千個，而是在100以下。一般情況下，我們只創建少數幾個關鍵執行緒，用它們解決某個特定的問題。這時數量的限制問題不大。但在較常規的一些設計中，這一限制確實會使我們感到束手束腳。

大家要注意執行緒處理中一個不是十分直觀的問題。由於採用了執行緒“調度”機制，所以通過在`run()`的主循環中插入對`sleep()`的呼叫，一般都可以使自己的程序運行得更快一些。這使它對編程技巧的要求非常高，特別是在更長的延遲似乎反而能提高性能的時候。當然，之所以會出現這種情況，是由於在正在運行的執行緒準備進入“休眠”狀態之前，較短的延遲可能造成“`sleep()`結束”調度機制的中斷。這便強迫調度機制將其中止，並於稍後重新啟動，以便它能做完自己的事情，再進入休眠狀態。必須多想一想，才能意識到事情真正的麻煩程度。

本章遺漏的一件事情是一個動畫例子，這是目前程序片最流行的一種應用。然而，Java JDK配套提供瞭解決這個問題的一整套方法（並可播放聲音），大家可到`java.sun.com`的演示區域下載。此外，我們完全有理由相信未來版本的Java會提供更好的動畫支持——儘管目前的Web湧現出了與傳統方式完全不同的非Java、非程序化的許多動畫方法。如果想系統學習Java動畫的工作原理，可參考《Core Java——核心Java》一書，由Cornell&Horstmann編著，Prentice-Hall於1997年出版。若欲更深入地瞭解執行緒處理，請參考《Concurrent Programming in Java——Java中的併發編程》，由Doug Lea編著，Addison-Wiseley於1997年出版；或者《Java Threads——Java執行緒》，Oaks&Wong編著，O'Reilly於1997年出版。


# 14.7 練習


(1) 從`Thread`繼承一個類，並（重載）覆蓋`run()`方法。在`run()`內，打印出一則訊息，然後呼叫`sleep()`。重複三遍這些操作，然後從`run()`返回。在建構子中放置一條啟動訊息，並覆蓋`finalize()`，打印一條關閉訊息。創建一個獨立的執行緒類，使它在`run()`內呼叫`System.gc()`和`System.runFinalization()`，並打印一則訊息，表明呼叫成功。創建這兩種類型的幾個執行緒，然後運行它們，看看會發生什麼。

(2) 修改`Counter2.java`，使執行緒成為一個內部類，而且不需要明確保存指向`Counter2`的一個。

(3) 修改`Sharing2.java`，在`TwoCounter`的`run()`方法內部添加一個`synchronized`（同步）塊，而不是同步整個`run()`方法。

(4) 創建兩個`Thread`子類，第一個的`run()`方法用於最開始的啟動，並捕獲第二個`Thread`物件的引用，然後呼叫`wait()`。第二個類的`run()`應在過幾秒後為第一個執行緒呼叫`modifyAll()`，使第一個執行緒能打印出一則訊息。

(5) 在`Ticker2`內的`Counter5.java`中，刪除`yield()`，並解釋一下結果。用一個`sleep()`換掉`yield()`，再解釋一下結果。

(6) 在`ThreadGroup1.java`中，將對`sys.suspend()`的呼叫換成對執行緒組的一個`wait()`呼叫，令其等候2秒鐘。為了保證獲得正確的結果，必須在一個同步塊內取得`sys`的物件鎖。

(7) 修改`Daemons.java`，使`main()`有一個`sleep()`，而不是一個`readLine()`。實驗不同的睡眠時間，看看會有什麼發生。

(8) 到第7章（中間部分）找到那個`GreenhouseControls.java`例子，它應該由三個文件構成。在`Event.java`中，`Event`類建立在對時間的監視基礎上。修改這個`Event`，使其成為一個執行緒。然後修改其餘的設計，使它們能與新的、以執行緒為基礎的Event正常協作。
