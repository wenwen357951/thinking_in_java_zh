# 附錄B 對比C++和Java


“作為一名C++程序員，我們早已掌握了物件導向程序設計的基本概念，而且Java的語法無疑是非常熟悉的。事實上，Java本來就是從C++派生出來的。”

然而，C++和Java之間仍存在一些顯著的差異。可以這樣說，這些差異代表著技術的極大進步。一旦我們弄清楚了這些差異，就會理解為什麼說Java是一種優秀的程序設計語言。本附錄將引導大家認識用於區分Java和C++的一些重要特徵。

(1) 最大的障礙在於速度：解釋過的Java要比C的執行速度慢上約20倍。無論什麼都不能阻止Java語言進行編譯。寫作本書的時候，剛剛出現了一些準實時編譯器，它們能顯著加快速度。當然，我們完全有理由認為會出現適用於更多流行平臺的純固有編譯器，但假若沒有那些編譯器，由於速度的限制，必須有些問題是Java不能解決的。

(2) 和C++一樣，Java也提供了兩種類型的註釋。

(3) 所有東西都必須置入一個類。不存在全局函式或者全局數據。如果想獲得與全局函式等價的功能，可考慮將s`tatic`方法和`static`數據置入一個類裡。注意沒有象結構、枚舉或者聯合這一類的東西，一切只有“類”（`Class`）！

(4) 所有方法都是在類的主體定義的。所以用C++的眼光看，似乎所有函式都已嵌入，但實情並非如何（嵌入的問題在後面講述）。

(5) 在Java中，類定義採取幾乎和C++一樣的形式。但沒有標誌結束的分號。沒有`class foo`這種形式的類聲明，只有類定義。

```
class aType()
void aMethod() {/* 方法主體 */}
}
```

(6) Java中沒有作用域範圍運算符`::`。Java利用點號做所有的事情，但可以不用考慮它，因為只能在一個類裡定義元素。即使那些方法定義，也必須在一個類的內部，所以根本沒有必要指定作用域的範圍。我們注意到的一項差異是對`static`方法的呼叫：使用`ClassName.methodName()`。除此以外，`package`（包）的名字是用點號建立的，並能用`import`關鍵字實作C++的`#include`的一部分功能。例如下面這個語句：

```
import java.awt.*;
```

（`#include`並不直接映射成`import`，但在使用時有類似的感覺。）

(7) 與C++類似，Java含有一系列“基本類型”（Primitive type），以實作更有效率的訪問。在Java中，這些類型包括`boolean`，`char`，`byte`，`short`，`int`，`long`，`float`以及`double`。所有基本類型的大小都是固有的，且與具體的機器無關（考慮到移植的問題）。這肯定會對性能造成一定的影響，具體取決於不同的機器。對類型的檢查和要求在Java裡變得更苛刻。例如：

+   條件表達式只能是`boolean`（布爾）類型，不可使用整數。

+   必須使用象`X+Y`這樣的一個表達式的結果；不能僅僅用`X+Y`來實作“副作用”。

(8) `char`（字符）類型使用國際通用的16位Unicode字符集，所以能自動錶達大多數國家的字符。

(9) 靜態引用的字符串會自動轉換成`String`物件。和C及C++不同，沒有獨立的靜態字符數組字符串可供使用。

(10) Java增添了三個右移位運算符`>>>`，具有與“邏輯”右移位運算符類似的功用，可在最末尾插入零值。`>>`則會在移位的同時插入符號位（即“算術”移位）。

(11) 儘管表面上類似，但與C++相比，Java數組採用的是一個頗為不同的結構，並具有獨特的行為。有一個只讀的`length`成員，通過它可知道數組有多大。而且一旦超過數組邊界，運行期檢查會自動丟棄一個異常。所有數組都是在內存“堆”裡創建的，我們可將一個數組分配給另一個（只是簡單地複製數組引用）。數組標識符屬於第一級物件，它的所有方法通常都適用於其他所有物件。

(12) 對於所有不屬於基本類型的物件，都只能通過`new`命令創建。和C++不同，Java沒有相應的命令可以“在棧上”創建不屬於基本類型的物件。所有基本類型都只能在棧上創建，同時不使用new命令。所有主要的類都有自己的“封裝（器）”類，所以能夠通過`new`創建等價的、以內存“堆”為基礎的物件（基本類型數組是一個例外：它們可象C++那樣通過集合初始化進行分配，或者使用`new`）。

(13) Java中不必進行提前聲明。若想在定義前使用一個類或方法，只需直接使用它即可——編譯器會保證使用恰當的定義。所以和在C++中不同，我們不會碰到任何涉及提前引用的問題。

(14) Java沒有預處理機。若想使用另一個庫裡的類，只需使用`import`命令，並指定庫名即可。不存在類似於預處理機的宏。

(15) Java用包代替了命名空間。由於將所有東西都置入一個類，而且由於採用了一種名為“封裝”的機制，它能針對類名進行類似於命名空間分解的操作，所以命名的問題不再進入我們的考慮之列。數據包也會在單獨一個庫名下收集庫的組件。我們只需簡單地`import`（導入）一個包，剩下的工作會由編譯器自動完成。

(16) 被定義成類成員的物件引用會自動初始化成`null`。對基本類數據成員的初始化在Java裡得到了可靠的保障。若不明確地進行初始化，它們就會得到一個默認值（零或等價的值）。可對它們進行明確的初始化（顯式初始化）：要麼在類內定義它們，要麼在建構子中定義。採用的語法比C++的語法更容易理解，而且對於`static`和非`static`成員來說都是固定不變的。我們不必從外部定義`static`成員的存儲方式，這和C++是不同的。

(17) 在Java裡，沒有象C和C++那樣的指針。用`new`創建一個物件的時候，會獲得一個引用（本書一直將其稱作“引用”）。例如：

```
String s = new String("howdy");
```

然而，C++引用在創建時必須進行初始化，而且不可重定義到一個不同的位置。但Java引用並不一定侷限於創建時的位置。它們可根據情況任意定義，這便消除了對指針的部分需求。在C和C++裡大量採用指針的另一個原因是為了能指向任意一個內存位置（這同時會使它們變得不安全，也是Java不提供這一支持的原因）。指針通常被看作在基本變量數組中四處移動的一種有效手段。Java允許我們以更安全的形式達到相同的目標。解決指針問題的終極方法是“固有方法”（已在附錄A討論）。將指針傳遞給方法時，通常不會帶來太大的問題，因為此時沒有全局函式，只有類。而且我們可傳遞對物件的引用。Java語言最開始聲稱自己“完全不採用指針！”但隨著許多程序員都質問沒有指針如何工作？於是後來又聲明“採用受到限制的指針”。大家可自行判斷它是否“真”的是一個指針。但不管在何種情況下，都不存在指針“算術”。

(18) Java提供了與C++類似的“建構子”（Constructor）。如果不自己定義一個，就會獲得一個默認建構子。而如果定義了一個非默認的建構子，就不會為我們自動定義默認建構子。這和C++是一樣的。注意沒有複製建構子，因為所有參數都是按引用傳遞的。

(19) Java中沒有“析構器”（Destructor）。變量不存在“作用域”的問題。一個物件的“存在時間”是由物件的存在時間決定的，並非由垃圾收集器決定。有個`finalize()`方法是每一個類的成員，它在某種程度上類似於C++的“析構器”。但`finalize()`是由垃圾收集器呼叫的，而且只負責釋放“資源”（如打開的文件、套接字、端口、URL等等）。如需在一個特定的地點做某樣事情，必須創建一個特殊的方法，並呼叫它，不能依賴`finalize()`。而在另一方面，C++中的所有物件都會（或者說“應該”）析構，但並非Java中的所有物件都會被當作“垃圾”收集掉。由於Java不支持析構器的概念，所以在必要的時候，必須謹慎地創建一個清除方法。而且針對類內的基類以及成員物件，需要明確呼叫所有清除方法。

(20) Java具有方法“重載”機制，它的工作原理與C++函式的重載幾乎是完全相同的。

(21) Java不支持默認參數。

(22) Java中沒有`goto`。它採取的無條件跳轉機制是“`break` 標籤”或者“`continue` 標準”，用於跳出當前的多重嵌套循環。

(23) Java採用了一種單根式的分級結構，因此所有物件都是從根類`Object`統一繼承的。而在C++中，我們可在任何地方啟動一個新的繼承樹，所以最後往往看到包含了大量樹的“一片森林”。在Java中，我們無論如何都只有一個分級結構。儘管這表面上看似乎造成了限制，但由於我們知道每個物件肯定至少有一個`Object`接口，所以往往能獲得更強大的能力。C++目前似乎是唯一沒有強制單根結構的唯一一種OO語言。

(24) Java沒有模板或者參數化類型的其他形式。它提供了一系列集合：`Vector`（向量），`Stack`（棧）以及`Hashtable`（散列表），用於容納`Object`引用。利用這些集合，我們的一系列要求可得到滿足。但這些集合並非是為實作象C++“標準模板庫”（STL）那樣的快速呼叫而設計的。Java 1.2中的新集合顯得更加完整，但仍不具備正宗模板那樣的高效率使用手段。

(25) “垃圾收集”意味著在Java中出現內存漏洞的情況會少得多，但也並非完全不可能（若呼叫一個用於分配存儲空間的固有方法，垃圾收集器就不能對其進行跟蹤監視）。然而，內存漏洞和資源漏洞多是由於編寫不當的`finalize()`造成的，或是由於在已分配的一個塊尾釋放一種資源造成的（“析構器”在此時顯得特別方便）。垃圾收集器是在C++基礎上的一種極大進步，使許多編程問題消彌於無形之中。但對少數幾個垃圾收集器力有不逮的問題，它卻是不大適合的。但垃圾收集器的大量優點也使這一處缺點顯得微不足道。

(26) Java內建了對多執行緒的支持。利用一個特殊的`Thread`類，我們可通過繼承創建一個新執行緒（放棄了`run()`方法）。若將`synchronized`（同步）關鍵字作為方法的一個類型限制符使用，相互排斥現象會在物件這一級發生。在任何給定的時間，只有一個執行緒能使用一個物件的`synchronized`方法。在另一方面，一個`synchronized`方法進入以後，它首先會“鎖定”物件，防止其他任何`synchronized`方法再使用那個物件。只有退出了這個方法，才會將物件“解鎖”。在執行緒之間，我們仍然要負責實作更復雜的同步機制，方法是創建自己的“監視器”類。遞歸的`synchronized`方法可以正常運作。若執行緒的優先等級相同，則時間的“分片”不能得到保證。

(27) 我們不是象C++那樣控制聲明程式碼塊，而是將訪問限定符（`public`，`private`和`protected`）置入每個類成員的定義裡。若未規定一個“顯式”（明確的）限定符，就會默認為“友好的”（`friendly`）。這意味著同一個包裡的其他元素也可以訪問它（相當於它們都成為C++的“friends”——朋友），但不可由包外的任何元素訪問。類——以及類內的每個方法——都有一個訪問限定符，決定它是否能在文件的外部“可見”。`private`關鍵字通常很少在Java中使用，因為與排斥同一個包內其他類的訪問相比，“友好的”訪問通常更加有用。然而，在多執行緒的環境中，對`private`的恰當運用是非常重要的。Java的`protected`關鍵字意味著“可由繼承者訪問，亦可由包內其他元素訪問”。注意Java沒有與C++的`protected`關鍵字等價的元素，後者意味著“只能由繼承者訪問”（以前可用“private `protected`”實作這個目的，但這一對關鍵字的組合已被取消了）。

(28) 嵌套的類。在C++中，對類進行嵌套有助於隱藏名稱，並便於程式碼的組織（但C++的“命名空間”已使名稱的隱藏顯得多餘）。Java的“封裝”或“打包”概念等價於C++的命名空間，所以不再是一個問題。Java 1.1引入了“內部類”的概念，它祕密保持指向外部類的一個引用——創建內部類物件的時候需要用到。這意味著內部類物件也許能訪問外部類物件的成員，毋需任何條件——就好象那些成員直接隸屬於內部類物件一樣。這樣便為回調問題提供了一個更優秀的方法——C++是用指向成員的指針解決的。

(29) 由於存在前面介紹的那種內部類，所以Java裡沒有指向成員的指針。

(30) Java不存在“嵌入”（`inline`）方法。Java編譯器也許會自行決定嵌入一個方法，但我們對此沒有更多的控制權力。在Java中，可為一個方法使用final關鍵字，從而“建議”進行嵌入操作。然而，嵌入函式對於C++的編譯器來說也只是一種建議。

(31) Java中的繼承具有與C++相同的效果，但採用的語法不同。Java用`extends`關鍵字標誌從一個基類的繼承，並用`super`關鍵字指出準備在基類中呼叫的方法，它與我們當前所在的方法具有相同的名字（然而，Java中的`super`關鍵字只允許我們訪問父類的方法——亦即分級結構的上一級）。通過在C++中設定基類的作用域，我們可訪問位於分級結構較深處的方法。亦可用`super`關鍵字呼叫基類建構子。正如早先指出的那樣，所有類最終都會從Object裡自動繼承。和C++不同，不存在明確的建構子初始化列表。但編譯器會強迫我們在建構子主體的開頭進行全部的基類初始化，而且不允許我們在主體的後面部分進行這一工作。通過組合運用自動初始化以及來自未初始化物件引用的異常，成員的初始化可得到有效的保證。

```
public class Foo extends Bar {
  public Foo(String msg) {
    super(msg); // Calls base constructor
  }
  public baz(int i) { // Override
    super.baz(i); // Calls base method
  }
}
```

(32) Java中的繼承不會改變基類成員的保護級別。我們不能在Java中指定`public`，`private`或者`protected`繼承，這一點與C++是相同的。此外，在派生類中的優先方法不能減少對基類方法的訪問。例如，假設一個成員在基類中屬於`public`，而我們用另一個方法代替了它，那麼用於替換的方法也必須屬於`public`（編譯器會自動檢查）。

(33) Java提供了一個`interface`關鍵字，它的作用是創建抽象基類的一個等價物。在其中填充抽象方法，且沒有數據成員。這樣一來，對於僅僅設計成一個接口的東西，以及對於用`extends`關鍵字在現有功能基礎上的擴展，兩者之間便產生了一個明顯的差異。不值得用`abstract`關鍵字產生一種類似的效果，因為我們不能創建屬於那個類的一個物件。一個`abstract`（抽象）類可包含抽象方法（儘管並不要求在它裡麵包含什麼東西），但它也能包含用於具體實作的程式碼。因此，它被限制成一個單一的繼承。通過與接口聯合使用，這一方法避免了對類似於C++虛擬基類那樣的一些機制的需要。

為創建可進行“例示”（即創建一個實例）的一個`interface`（接口）的版本，需使用`implements`關鍵字。它的語法類似於繼承的語法，如下所示：


```
public interface Face {
  public void smile();
}
public class Baz extends Bar implements Face {
  public void smile( ) {
    System.out.println("a warm smile");
  }
}
```

(34) Java中沒有`virtual`關鍵字，因為所有非`static`方法都肯定會用到動態綁定。在Java中，程序員不必自行決定是否使用動態綁定。C++之所以採用了`virtual`，是由於我們對性能進行調整的時候，可通過將其省略，從而獲得執行效率的少量提升（或者換句話說：“如果不用，就沒必要為它付出代價”）。`virtual`經常會造成一定程度的混淆，而且獲得令人不快的結果。`final`關鍵字為性能的調整規定了一些範圍——它向編譯器指出這種方法不能被取代，所以它的範圍可能被靜態約束（而且成為嵌入狀態，所以使用C++非`virtual`呼叫的等價方式）。這些優化工作是由編譯器完成的。

(35) Java不提供多重繼承機制（MI），至少不像C++那樣做。與`protected`類似，MI表面上是一個很不錯的主意，但只有真正面對一個特定的設計問題時，才知道自己需要它。由於Java使用的是“單根”分級結構，所以只有在極少的場合才需要用到MI。`interface`關鍵字會幫助我們自動完成多個接口的合併工作。

(36) 運行期的類型識別功能與C++極為相似。例如，為獲得與引用X有關的信息，可使用下述程式碼：

```
X.getClass().getName();
```

為進行一個“類型安全”的緊縮轉換，可使用：

```
derived d = (derived)base;
```

這與舊式風格的C轉換是一樣的。編譯器會自動呼叫動態轉換機制，不要求使用額外的語法。儘管它並不像C++的`new casts`那樣具有易於定位轉換的優點，但Java會檢查使用情況，並丟棄那些“異常”，所以它不會象C++那樣允許壞轉換的存在。

(37) Java採取了不同的異常控制機制，因為此時已經不存在建構子。可添加一個`finally`從句，強制執行特定的語句，以便進行必要的清除工作。Java中的所有異常都是從基類`Throwable`裡繼承而來的，所以可確保我們得到的是一個通用接口。

```
public void f(Obj b) throws IOException {
  myresource mr = b.createResource();
  try {
    mr.UseResource();
  } catch (MyException e) {
    // handle my exception
  } catch (Throwable e) {
    // handle all other exceptions
  } finally {
    mr.dispose(); // special cleanup
  }
}
```

(38) Java的異常規範比C++的出色得多。丟棄一個錯誤的異常後，不是象C++那樣在運行期間呼叫一個函式，Java異常規範是在編譯期間檢查並執行的。除此以外，被取代的方法必須遵守那一方法的基類版本的異常規範：它們可丟棄指定的異常或者從那些異常派生出來的其他異常。這樣一來，我們最終得到的是更為“健壯”的異常控制程式碼。

(39) Java具有方法重載的能力，但不允許運算符重載。`String`類不能用`+`和`+=`運算符連接不同的字符串，而且`String`表達式使用自動的類型轉換，但那是一種特殊的內建情況。

(40) 通過事先的約定，C++中經常出現的`const`問題在Java裡已得到了控制。我們只能傳遞指向物件的引用，本地副本永遠不會為我們自動生成。若希望使用類似C++按值傳遞那樣的技術，可呼叫`s`，生成參數的一個本地副本（儘管`clone()`的設計依然尚顯粗糙——參見第12章）。根本不存在被自動呼叫的副本建構子。為創建一個編譯期的常數值，可象下面這樣編碼：

```
static final int SIZE = 255
static final int BSIZE = 8 * SIZE
```

(41) 由於安全方面的原因，“應用程序”的編程與“程序片”的編程之間存在著顯著的差異。一個最明顯的問題是程序片不允許我們進行磁盤的寫操作，因為這樣做會造成從遠程站點下載的、不明來歷的程序可能胡亂改寫我們的磁盤。隨著Java 1.1對數字簽名技術的引用，這一情況已有所改觀。根據數字簽名，我們可確切知道一個程序片的全部作者，並驗證他們是否已獲得授權。Java 1.2會進一步增強程序片的能力。

(42) 由於Java在某些場合可能顯得限制太多，所以有時不願用它執行象直接訪問硬件這樣的重要任務。Java解決這個問題的方法是“固有方法”，允許我們呼叫由其他語言寫成的函式（目前只支持C和C++）。這樣一來，我們就肯定能夠解決與平臺有關的問題（採用一種不可移植的形式，但那些程式碼隨後會被隔離起來）。程序片不能呼叫固有方法，只有應用程序才可以。

(43) Java提供對註釋文檔的內建支持，所以源碼文件也可以包含它們自己的文檔。通過一個單獨的程序，這些文檔信息可以提取出來，並重新格式化成HTML。這無疑是文檔管理及應用的極大進步。

(44) Java包含了一些標準庫，用於完成特定的任務。C++則依靠一些非標準的、由其他廠商提供的庫。這些任務包括（或不久就要包括）：

+   連網

+   數據庫連接（通過JDBC）

+   多執行緒

+   分佈式物件（通過RMI和CORBA）

+   壓縮

+   商貿

由於這些庫簡單易用，而且非常標準，所以能極大加快應用程序的開發速度。

(45) Java 1.1包含了Java Beans標準，後者可創建在可視編程環境中使用的組件。由於遵守同樣的標準，所以可視組件能夠在所有廠商的開發環境中使用。由於我們並不依賴一家廠商的方法進行可視組件的設計，所以組件的選擇餘地會加大，並可提高組件的效能。除此之外，Java Beans的設計非常簡單，便於程序員理解；而那些由不同的廠商開發的專用組件框架則要求進行更深入的學習。

(46) 若訪問Java引用失敗，就會丟棄一次異常。這種丟棄測試並不一定要正好在使用一個引用之前進行。根據Java的設計規範，只是說異常必須以某種形式丟棄。許多C++運行期系統也能丟棄那些由於指針錯誤造成的異常。

(47) Java通常顯得更為健壯，為此採取的手段如下：

+   物件引用初始化成`null`（一個關鍵字）

+   引用肯定會得到檢查，並在出錯時丟棄異常

+   所有數組訪問都會得到檢查，及時發現邊界異常情況

+   自動垃圾收集，防止出現內存漏洞

+   明確、“傻瓜式”的異常控制機制

+   為多執行緒提供了簡單的語言支持

+   對網絡程序片進行字節碼校驗
